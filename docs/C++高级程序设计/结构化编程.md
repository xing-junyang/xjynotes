

# 结构化编程

## ADT

- 抽象数据类型： `array`、`struct`、`union` 等。
- 结合性
- 优先级
- 类型转换： `coersion`（隐式转换） 和 `casting`（强制转换），溢出处理；
- 运算顺序：副作用和精度

::: tip 声明 `cast`

- `static.cast <TYPE> (DATA)`：是最常用的类型转换之一，在编译时刻做**表示形式级别**的转换，适用于大多数显式类型转换。相对于直接类型转换，这种方式可以提供**更强的类型检查**。一般用于基础的类型转换（如 `int` 和 `float` 等。

- `const.cast <TYPE> (DATA)`：`const_cast` 是用于**移除或添加 `const` 或 `volatile` 修饰符**的唯一合法方法。它可以将 `const` 对象的常量性去掉，使其可以被修改，或者反之。例如：

  ```c++
  const int i = 42;
  int* p = const_cast<int*>(&i);  // 移除 const，允许修改 i
  *p = 24;  // 可能会产生未定义行为 // [!code error]
  ```

  **注意：** 如果对原本是常量的对象进行修改，**结果是未定义行为，一般的编译器会在直接引用常量时填入原来的值，而在对指针解引用时返回新值**。因此需谨慎使用 `const_cast`。

- `dynamic.cast <TYPE> (DATA)`：主要用于**类层次**结构中，尤其是在有虚函数的多态情况下。它会在运行时进行类型检查，确保转换是安全的。它可以**向上转换**（将派生类对象转换为基类类型）和**向下转换**（将基类对象转换为派生类类型）。如果转换失败，指针类型会返回 `nullptr`，而引用类型会抛出 `std::bad_cast` 异常。

- `reinterpret.cast <TYPE> (DATA)`：是一种**非常危险**的转换，它允许几乎任意类型之间的强制转换，甚至可以将指针转换为整数，或者将整数转换为指针。它不会执行任何类型检查或安全保证，适用于底层操作和低级别编程。

:::