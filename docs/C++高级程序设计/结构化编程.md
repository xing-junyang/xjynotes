

# 结构化编程

## 基本内容

- 结合性
- 优先级
- 类型转换： `coersion`（隐式转换） 和 `casting`（强制转换），溢出处理；
- 运算顺序：副作用和精度

::: tip 声明 `cast`

- `static.cast <TYPE> (DATA)`：是最常用的类型转换之一，在编译时刻做**表示形式级别**的转换，适用于大多数显式类型转换。相对于直接类型转换，这种方式可以提供**更强的类型检查**。一般用于基础的类型转换（如 `int` 和 `float` 等。

- `const.cast <TYPE> (DATA)`：`const_cast` 是用于**移除或添加 `const` 或 `volatile` 修饰符**的唯一合法方法。它可以将 `const` 对象的常量性去掉，使其可以被修改，或者反之。例如：

  ```c++
  const int i = 42;
  int* p = const_cast<int*>(&i);  // 移除 const，允许修改 i
  *p = 24;  // 可能会产生未定义行为 // [!code error]
  ```

  **注意：** 如果对原本是常量的对象进行修改，**结果是未定义行为，一般的编译器会在直接引用常量时填入原来的值，而在对指针解引用时返回新值**。因此需谨慎使用 `const_cast`。

- `dynamic.cast <TYPE> (DATA)`：主要用于**类层次**结构中，尤其是在有虚函数的多态情况下。它会在运行时进行类型检查，确保转换是安全的。它可以**向上转换**（将派生类对象转换为基类类型）和**向下转换**（将基类对象转换为派生类类型）。如果转换失败，指针类型会返回 `nullptr`，而引用类型会抛出 `std::bad_cast` 异常。

  考虑下面的一个简单的基类和派生类：

  ```c++
  class F {
  public:
      void foo() {
          cout << "Father" << endl;
      }
  };

  class S1 : public F {
  public:
      int x = 1;

      void foo() {
          cout << "Son1" << endl;
      }
  };

  class S2 : public F {
  public:
      int x = 2;

      void foo() {
          cout << "Son2" << endl;
      }
  };
  ```

  运行一下几组代码，可以看出 `dynamic_cast` 具有更强的类型检查：

  ```c++
  F* obj = new S1;
  obj->foo();	//print 'Father'
  static_cast<S1*>(obj)->foo();	//print 'Son1'

  F* obj1 = new F;
  static_cast<S1*>(obj1)->foo();	//Unsafe
  cout << static_cast<S1 *>(obj1)->x << endl;	//Undefined behavior

  F* obj2 = new S1;
  dynamic_cast<S1*>(obj2)->foo();	//Compile Error...

  F* obj3 = new F;
  dynamic_cast<S1*>(obj3)->foo();	//Exception
  ```


- `reinterpret.cast <TYPE> (DATA)`：**它保持位的二进制序列不变，只是以新的类型解释变量**。这是一种**非常危险**的转换，它允许几乎任意类型之间的强制转换，甚至可以将指针转换为整数，或者将整数转换为指针。它不会执行任何类型检查或安全保证，适用于底层操作和低级别编程。

:::

## 表达式

- `auto` 关键字：可以使用 `auto` 关键字来避免冗余的类型定义。

- `decltype` 关键字：用法是 `decltype (实体或表达式)`，推导出一个与括号中实体相同的类型，并将该类型作用于后面的对象。例如

  ```c++
  int i = 33;
  decltype(i) j = i * 2;	//Type of j is int
  ```

- 使用 `range-for` 使语法简洁：这是 `C++` 中新增的**语法糖**。如果只是遍历容器中的元素，就可以使用 `range-for` 语法来简化，如下

  ```c++
  vector<int> v = {1, 2, 3, 4, 5};
  for (int i : v) {
      cout << i << endl;
  }
  ```

## 抽象数据类型

### `union` 组合体

`union` 是一种特殊的数据结构，它允许在相同的内存位置存储不同的数据类型。`union` 的大小是其成员中最大的成员的大小。其核心思想就是**共享内存**。如果某一组合体最近被写入为某一个成员变量的类型，那么就只能按这一类型读取，否则会出现未定义行为。例如可以定义以下数据结构 `S`：

```c++
union S
{
    std::int32_t n;     // 占用 4 字节
    std::uint16_t s[2]; // 占用 4 字节
    std::uint8_t c;     // 占用 1 字节
};                      // 整个联合体占用 4 字节
```

下面我们来看一个例子：

```c++
#include <cstdint>
#include <iostream>
int main()
{
    S s = {0x12345678}; // 初始化首个成员，s.n 现在是活跃成员
    // 于此点，从 s.s 或 s.c 读取是未定义行为
    std::cout << std::hex << "s.n = " << s.n << '\n';
    s.s[0] = 0x0011; // s.s 现在是活跃成员
    // 在此点，从 n 或 c 读取是 UB 但大多数编译器都对其有定义
    std::cout << "s.c 现在是 " << +s.c << '\n' // 11 或 00，取决于平台
              << "s.n 现在是 " << s.n << '\n'; // 12340011 或 00115678
}
```

这一程序的输出是：

```c++
s.n = 12345678
s.c 现在是 11
s.n 现在是 12340011
```
我们可以看出，利用 `Union` 可以实现简单的**多态**。

### `struct` 结构体

`struct` 是一种用户自定义的数据类型，它可以包含不同类型的数据成员。和 `class` 一样，`struct` 也是类关键词。但 `struct` 的默认访问权限是 `public`，而 `class` 的默认访问权限是 `private`。`struct` 可以包含成员函数，但是不能包含构造函数和析构函数。此外，`struct` 可以继承自其他类，也可以作为基类被继承。


::: tip 结构体内存布局

在结构体对象内，其成员的地址（及位域分配单元的地址）按照**成员定义的顺序递增**。可以把指向结构体的指针转型为指向其首成员（或者若首成员为位域，则指向其分配单元）的指针。类似地，能转型指向结构体首成员的指针为指向整个结构体的指针。**在任意两个成员间和最后的成员后可能存在无名的填充字节（亦称对齐），但首成员前不会有**。结构体的大小至少与其成员的大小之和一样大。

:::

### 数组

将一段相同数据类型的数据聚合到一段连续的地址空间中，并与 $0\sim n-1$ 的标号产生映射。

**数组传递到函数中时，会发生类型转换**。如 `int a[8]` 中的 `a` 传递到 `void f(int a[])` 当中时，函数中的 `a` 实际类型是 `int* const`，即一个指针。

## 返回值

### 返回多个参数

**使用引用参数**：通过在参数列表中使用引用参数，可以允许在函数内部操作外部环境的变量，这样，函数对这些引用变量的影响可以传播到外部，这就相当于函数的输出。例如，下面的代码便展示了这种输出

```c++
void swap(int& i, int& j){
  	int k = i;
  	i = j;
  	j = k;
}
```

**使用结构体作为返回值**：可以先声明结构体，再在函数中创建这一结构体并返回即可。这一方式的缺点是声明的结构体大多数情况只是临时使用的，看起来过于冗余。

```c++
struct Pair{
  	int i;
  	int j;
}

Pair swap(int& i, int& j){
  	int k = i;
  	i = j;
  	j = k;
  	return {i, j};
}
```

**使用元组来作为返回值**：元组可以作为临时返回一组参数的选择，这一方式在 `C++` 中提高了编码的效率。元组既可以容纳两个变量，还可以**容纳多个变量**。

```c++
tuple<int, float> foo(){
		return {1, 3.0f}
}

int main(){
  	auto r = foo();
  	std::cout << get<0>(r) << " " << get<1>(r) << std::endl;
  	auto [i, f] = r;	//可以快速赋值给 i, f
  	std::cout<< i << " " << f << std::endl;
}
```

### `optional`：可选返回值

如果一个函数通常返回某类型的值，但遇到某些特殊情况不需要返回或不知返回何值，此时就可以使用 `optional` 来进行返回值的封装。当不返回有效值时，我们返回一个 `nullopt`，然后可以在函数外部接收并判断。

```c++
#include<optional>
std::optional<string> getNameByID(const vector<std::pair<int, string>>& v, int id){
		for(auto e : v){
      	if(e.first == id){
          	return e.second;
        }
    }
  	return std::nullopt;
}

int main(){
  	using namespace std;
  	vector<std::pair<int, string>> students{{1, "AAA"}, {2, "BBB"}, {3, "CCC"}};
  	int student_id;
  	cin >> student_id;
  	auto id = getNameByID(students, student_id);
  	
  	if(id.has_value()){
      	cout << id.value() << endl;
    }else{
      	cout << "NOT FOUND!" << endl;
    }
  
  	cout << id.value_or("NOT FOUND") << endl; // we can simplify output to one statement.
}
```

### `variant`：类型安全组合体

即 type-safe `union`。`union` 的问题是可能当中的内容与解释的类型是不相符的，这会导致一系列安全性问题。而 `variant` 可以提供更严格的类型检查，在编译时或运行中阻止不正确的访问。

```c++
std::variant<int, float, string> v;
v = "abc";
cout << v.index() << " " << std::get<string>(v) << endl; // string, OK
v = 100;
cout << v.index() << " " << std::get<0>(v) << endl; // int, OK
v = 2.3f;
cout << v.index() << " " << std::get<float>(v) << endl; // float, OK
cout << v.index() << " " << std::get<double>(v) << endl; // double, not found in type list, compile ERROR // [!code error]

cout << v.index() << " " << std::get<int>(v) << endl; // int, not the corresponding type, runtime exception // [!code error]

float* pf = std::get_if<float>(&v); // we can use guard pointer to judge.
if(pf != nullptr){ // float, OK
  	cout << v.index() << " " << std::get<float>(v) << endl;
}else{ // not float, invalid! // [!code error]
  	cout << "Invalid" << endl;
}
```

### `any`：任何类型的容器

如果不能将返回值显式地表现出来，可以直接用 `any` 来进行封装。`any` 相当于是一个篮子，它可以接受任何类型的返回值。它相当于是更安全的 `void*`。

```c++
any input(){
  	int i;
  	cin >> i;
  	switch(i){
	      case 0: 
        		return 11;
        		break;
	      case 1:
  					return 3.14;
        		break;
      	default:
        		return string("Hello, world!");
        		break;
    }
}

int main(){
  	any aa;
  	aa = input();
  	if(aa.type() == typeid(int)){
      	// do something...
    }else if(aa.type() == typeid(double)){
      	// do something...
    }else{
      	// do something...
    }
}
```

## 指针

指针让我们可以动态地调配内存中的空间，还可以让我们在一定范围内直接操作内存。可以用指针访问变量、数组中的元素、甚至代码（函数指针）。

### 动态变量

在 `C++` 中，除了从 `C` 继承过来的 `malloc` 和 `free`，还可以用 `new` 和 `delete` 来生成和回收动态变量。

```C++
int *p = new int[8]; // int *p = (int *)malloc(sizeof(int) * 8)
delete[] p; //free(p)
```

当 `new` 时使用了 `[]`，那么需要在释放时也应当使用。对于申请得来的指针，**切勿轻易移动它**，防止在 `delete` 时出现问题。

`new` 和 `malloc` 最大的区别是，当生成的是类的实例时，`new` 会自动调用类的构造函数（如果生成的是数组，则逐个调用）；`delete` 也同理，它会自动调用类的析构函数，而 `delete []` 则可以逐个调用数组的析构函数。

使用指针需要时刻注意**严禁出现空闲指针**，并**谨防内存泄露**；

为了减少泄漏的风险，`C++` 引入了智能指针 `unique_ptr`，如下

```c++
void old_use(Args* a){
	  auto q = new Blob(a);
  	//...
  	if(foo) throw Bad(); //	q leak... // [!code error]
  	if(bar) return; // also leak... // [!code error]
  	delete q; // Don't forget! // [!code warning]
}

void newer_use(Args a){
  	auto p = unique_ptr<Blob>(new Blob(a));
  
  	if(foo) throw Bad();	// won't leak
  	if(bar) return; // won't leak
}
```

`unique_ptr` 可以在对象生命期结束时自动调用析构函数，这样就防止了内存泄露。我们还有其他两种智能指针：`shared_ptr` 和 `weak_ptr`。

[`shared_ptr`](https://zh.cppreference.com/w/cpp/memory/shared_ptr) 是一种通过指针保持对象共享所有权的智能指针，多个 `shared_ptr` 对象可持有同一对象。当最后一个持有对象的 `shared_ptr` 被销毁或被赋值为另一指针时，对象会被销毁。可以使用 `.use_count()` 来查看当前对象的引用计数。

```c++
std::shared_ptr<int> p1(new int(42)); // std::shared_ptr<int> p1 = std::make_shared<int>(42);
std::shared_ptr<int> p2 = p1; // p1 and p2 point to the same object
std::cout << p1.use_count() << std::endl; // 2
p1.reset(); // p1 release the object
std::cout << p2.use_count() << std::endl; // 1
```

[`weak_ptr`](https://zh.cppreference.com/w/cpp/memory/weak_ptr) 持有被 `shared_ptr` 管理的对象的非拥有性「弱」引用——当某个对象只有存在时才需要被访问，且随时可能被他人删除时，可以使用 `weak_ptr` 来跟踪该对象。在访问引用的对象前必须先转换为 `shared_ptr`。如果此时销毁了原始 `shared_ptr`，则对象的生命周期将被延长，直到临时 `shared_ptr` 也被销毁为止。

::: warning `NULL` or `nullptr`?

空指针是一个很常用的概念。最早的 `ANSI C` 利用宏定义来说明空指针 `#define NULL ((void *)0)`。这一定义方式欠佳，因为它使得 `void*` 可以被赋值到其他指针，造成了类型的转换的不严格。例如，`char* s = NULL` 是被允许的，这就导致了可以用 `char*` 来解释 `void*`。

而 `C++` 对这一宏定义做了改进：`#define NULL 0`。但这一方式也不好，它在某些多态情景下会失效。如，无法区分 `void foo(int)` 和 `void foo(char*)`。

因此，`C++` 又引入了 `nullptr`，将其作为**推荐的空指针写法**。它会被特殊处理，而不会简单地以宏定义的形式被替换。
:::