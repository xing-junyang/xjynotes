# OOP

## 引入 OOP

传统的面向过程编程，数据经常是无监管的，分散在代码中。它们可以随意被多个函数访问、使用、修改。这通常是不安全的。最初的 $\text{OOP}$ 就设想将数据封装起来，对数据的使用作出更严格限制。

我们可以看下面的栈的例子：

::: code-group

```c++[面向过程]
#include<iostream.h>
#define STACK_SIZE 100
struct Stack{
  	int top;
  	int buffer[STACK_SIZE];
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.top = -1;
  	st2.top = -1;
  	int x;
  	push(&st1, 12);
  	pop(&st1, x);
}
```



```c++[OOP]
#include<iostream.h>
#define STACK_SIZE 100
class Stack{
private:
  	int top;
  	int buffer[STACK_SIZE];
public:
  	Stack(){top = -1;}
  	bool push(int i);
  	bool pop(int &i);
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.push(12);
  	int x;
  	st2.pop(x);
}
```

:::

::: warning `C++` 中的 `class` 和 `struct`

在 `C++` 中，`class` 和 `struct` 基本相同。区别在于 `class` 内成员变量的默认访问权限是 `private`，而 `struct` 是 `public`。

:::

早期 `C++` 提供的面向对象机制，大体上属于逻辑的范畴，可以理解为一种代码检查的机制。它通过 `Cfront` 直接编译为 `C` 代码，因此**面向对象的引入不会增大运行时开销**。

我们知道，对象是数据和操作的集合，对象之间通过函数调用传递信息，而类提供对象的抽象。如果仅有这些特性，可以被称为**基于对象的语言**（*Object-Based*），这也是早期 `Ada` 等语言采取的范式。然而现代的**面向对象的语言**（*Object-Oriented*），通常还支持**继承**的机制。

## 类

我们刚刚提到，类是对象的抽象，而对象是数据和操作的集合。因此，类中有相对应的概念：**成员变量**和**成员函数**。如下面的示例：

```c++
//Tdate.h
class Tdate{
public:
  	void SetDate(int y, int m, int d); // 成员函数
  	int isLeapYear(); // 成员函数
private:
  	int year, month, day; // 成员变量
}

//Tdate.cpp
void TDate::SetDate(int y, int m, int d){
  	year = y;
  	month = m;
  	day = d;
}
int TDate::isLeapYear(){return (year%4 == 0 && year % 100 != 0) || (year % 100 == 0);}
```

同普通的函数一样，成员函数也需要**先定义后使用**。可以直接在类中声明时定义，也可以在类外定义。在类外定义时应当在函数名前加上类名和作用域解析符 `::`。

可以将类的定义和成员函数的实现分别放在头文件和 `cpp` 文件中，如上文所示。但如果成员函数的**实现较为简单**，则可以一并放入头文件，编译器会自动进行**内联**操作。

>[!NOTE] 头文件还是模块`C++ 20`？
>
>头文件是从 `C` 流传下来的库声明文件，它设计的初衷是结构清晰地将声明和实现分离。但它的设计存在一些缺陷，如**重复包含问题、引入顺序**和**大型项目效率低下**的问题。
>
>而 `C++20` 引入了模块机制，这是一种更现代化的代码组织方式。与传统的头文件不同，模块直接支持在语言层面进行依赖管理，以提高编译速度并减少复杂性。例如：
>
>::: code-group
>```c++[定义]
>// math_utils.ixx
>export module math_utils; // 定义模块并导出
>export int add(int a, int b) { // 直接实现和导出函数
>    return a + b;
>}
>```
>
>```c++[使用]
>import math_utils; // 导入模块
>#include <iostream>
>
>int main() {
>    std::cout << add(3, 4) << std::endl;
>    return 0;
>}
>```
>:::
> 
>使用 `export` 和 `import` 来进行模块的导入和导出。

在声明成员变量时可以指定**默认初始化**的值。`C++` 提供了两种方式：

```c++
class A{
    int a = 1;
    int b{2};
}
```

**推荐在每次声明成员变量时指定默认初始化的值**，防止出现奇奇怪怪的问题。

::: warning 注意

这种默认初始化的结果会被下面介绍的[**成员初始化表**](./面向对象编程初步.md#成员初始化表)所**覆盖**。也就是说，如果你声明了成员初始化表，那就相当于不会执行默认初始化。

:::

### 构造函数

构造函数可以用来初始化对象，如**分配内存和初始化值**等。构造函数有如下特点：

- **与类同名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 可以重载。
- 默认为 `public`，但可定义为 `private`，接管对象的创建（如**单例模式**）。

如果没有显式声明构造函数，那么编译器会自动补全**默认构造函数**。默认构造函数是无参数的。但**一旦显式声明了构造函数，编译器就不再提供**（当然，还可以通过在函数声明后加 `=default` 来显式声明默认构造函数）。

构造函数会在创建对象时，选择一个合适的使用。一般来说，范式有两种：

- `ClassName` `object-name` = `ClassName`(`Args`)
- `ClassName` `object-name`(`Args`)

可以参考下面的例子：

```c++
class A{
public:
  	A();
  	A(int i);
  	A(char *p);
}

A a1 = A(1);//此为显式初始化, 调用 A(int i)
            //也可以采用隐式初始化： 'A a1(1);' or 'A a1 = 1;'

A a2 = A(); //此为显式初始化, 调用 A()
            //也可以采用隐式初始化： 'A a2;'
            //注意：'A a2();' 不是初始化！这是一个函数的声明. // [!code error]

A a3 = A("abcd");   //此为显式初始化, 调用 A(char *p);
                    //也可以采用隐式初始化： 'A a3("abcd");' or 'A a3="abcd";', 

A a[4]; // 调用四次 A()
A b[5] = {A(), A(1), A('abcd'), 2, "xjy"};
```

::: tip 强制显式初始化

可以在构造函数类中定义前加 `explicit` 关键字，来避免通过隐式初始化构建对象。

:::

在函数体之外定义的类会首先执行**零初始化**，然后再执行默认初始化和自定义初始化，就像在函数体外定义内置类型的变量一样。

### 成员初始化表

成员初始化表是构造函数的补充，它可以对初始化提供更细致的操控，并**提高效率**。此外，对于**常量和引用成员**，必须在定义时**使用成员初始化表**进行初始化。

成员初始化表的语法为构造函数名后面添加 `: Member1(Value1), Member2(Value2), ...`。成员的声明顺序是类中的定义顺序，而**不是成员初始化表的顺序。**

当初始化时，如果需要初始化的常量比较少，应当使用成员初始化表以提高效率。否则，应当考虑在构造函数体内赋值。

### 析构函数

析构函数当**对象消亡时**自动调用，应当在这当中回收这一对象使用的资源，如释放内存，关闭文件和网络非内存资源等。它有如下特点：

- **名字为 `~` 加类名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 默认为 `public`，但可定义为 `private`。

### 拷贝构造函数

创建对象时，用同一类的对象对其进行初始化，这就是**拷贝构造**。自定义拷贝构造函数的**语法**是：

```c++
public:
	A(const A& a){
      	// Your own implemention...
    }
```

调用拷贝构造函数的场景有：

- `A b = a` 初始化赋值时；
- 函数按值传参时；
- 函数返回一个类时；

可以看出，如果将对象想象成 `int` 类型，则拷贝构造发生在大多数**初始化值传递**的情形。值传递时，如果原来对象的成员有指针，我们应当拷贝指针指向的内容，而不是指针本身（即**深拷贝**）。否则，当原对象消亡时，新对象的指针就会指向一个不存在的内存区域。

> [!NOTE] 深拷贝和浅拷贝
> 
> **浅拷贝**只是简单地将原对象的成员变量的值拷贝到新对象中；而**深拷贝**则是将原对象的指针指向的内容拷贝到新对象中，一般会再申请一块新的内存空间。

::: danger 如果自定义了拷贝构造函数...

如果类中含有**自定义**的拷贝构造函数，那么在执行拷贝之前，会先执行新对象的**默认构造函数**（注意，**即使有自定义的构造函数，也会执行默认的！**），然后再执行自定义的拷贝构造函数。否则，如果没有进行自定义，直接调用成员对象的**默认拷贝函数**。

也就是说，如果自定义了拷贝构造函数，编译器就不会自己发挥，而是按照**最简单**（**但不一定最符合直觉**）的方式执行（即初始化）。

:::

但是，有时拷贝构造函数也会拖慢速度，例如下面的代码：

```c++
string generate(){
  	return string("test");
}
string S = generate();
```

这段简短的代码竟然执行了两次拷贝构造函数（假设没有移动构造函数的话）！一次用于将 `generate()` 临时变量拷贝到调用者栈帧中的无名变量，另一次用于将无名变量拷贝至 `S`。事实上，我们只需要将临时变量中的地址传给 `S` 就行了（类似值传递和引用传递的区别）。下面我们介绍的**移动构造函数**，解决了这一问题。

### 移动构造函数

左值是能通过名称访问的一块内存，而右值要么没有名称，要么无法被访问。非 `const` 的引用是一个左值。右值对象一般是没有名称的，或者是一个临时对象。因此许多情况下，右值的内存是一经赋值，不会再次被使用的。这时，我们可以直接在赋值时让左值来**全盘接管**右值的内存，就省去了拷贝构造的时间，这就是**移动构造函数**的主要思想。

移动构造函数的语法是：

```c++
public:
	A(A&& rvalue){
      	// Your own implemention...
    }
```

一般而言，移动构造函数不应该申领任何资源，所以不该抛出异常，可以加上 `noexcept` 关键字。

例如，我们可以看下面矩阵类 `Matrix` 的例子：

```c++
class Matrix {
    int n{0};
    int *mat{nullptr};

public:
    // Some constructors and functions...

    Matrix(Matrix && other) noexcept :n(other.n), mat(other.mat){
        other.mat = nullptr;    // 将资源完全移交给新对象
    }

    Matrix& operator=(Matrix && other) noexcept{
        if(n!=other.n){
            return *this;
        }
        if(this != &other){
            delete [] this->mat;    // 注意：必须先释放原有资源   // [!code error]
            this->mat = other.mat;  // 移交资源
            other.mat = nullptr;    // 将资源完全移交给新对象
        }
        return *this;
    }

    // Destructor...
}
```

这样，当希望将**右值临时对象转交给左值**时，通过只转交地址，我们就可以避免上文的拷贝构造函数的问题。

> [!IMPORTANT] 注意
> 一般来说，**移动构造函数和拷贝构造函数是互斥的**，因为它们调用的时机有重叠，但是具体的操作是不同的。因此，我们可以通过 `=delete` 来禁用拷贝构造函数，只保留移动构造函数。
>
> 此外，移动构造函数一般还需要**重载赋值运算符**，以应对一般的赋值操作。

::: tip 重载运算符注意释放资源

在进行有重载运算符的移动构造时，要注意**提前释放被顶替**的资源，防止内存泄漏。

此外，还需要检查**自赋值**的情况，避免资源被提前释放。

:::

`lvalue` 是不能赋值给 `rvalue` 的。但我们可以使用 `std::move(lvalue)`，这将会生成一个对应的 `rvalue`。

## 动态对象

动态对象存放在**堆**上，而前面介绍的对象存放在**栈**上。`C++` 引入 `new` 和 `delete` 来新建和释放动态对象，实现内存管理。使用它们而非 `malloc` 和 `free` 的原因是：可以正确操作构造函数和析构函数。

`new` 的主要任务是：先在堆中申请内存，然后选择合适的构造函数进行调用；`delete` 的主要任务是：先调用析构函数，然后回收堆中的内存。

> [!NOTE] 提醒
> 
> 你可以对一个空指针调用 `delete`，但是不能对一个已经释放的指针调用 `delete`。这样会导致**未定义行为**。
> 
> 一个好的习惯是**在 `delete` 之后将指针设为 `nullptr`**，这样可以避免下面提到的野指针的问题。

动态对象的创建和释放可以参考下面的例子：

```c++
A *p, *q;
p = new A; // 申请内存，调用 A 的默认构造函数或者 A::A() (如果有的话)
q = new A(1); // 申请内存，调用 A::A(int)

delete p; // 调用析构函数，释放内存
delete q; // 调用析构函数，释放内存
```

与栈上的对象不同，**动态对象的创建和释放是与作用域解耦的**，因此可以利用这一性质申请全局可用的内存空间，同时也要谨防**内存泄露和野指针**。

::: danger 内存泄露和野指针

**内存泄露**指一块内存没有任何指向它的指针，那么它的位置信息也就丢失了。此时，如果程序不关闭，这一块内存就再也无法分配给其他对象，也就无法被使用了。因此，解决办法是在最后一个指向他的指针消失前，把内存释放。

**野指针**指指针指向的那块内存不可用，这很可能是因为指针没有正确初始化，或先前指向的内存区域已经被释放。前者的解决办法是严格遵循 $\text{RAII}$ 原则，后者的解决办法是**在每次 `delete` 时把相应的指针全部设为 `NULL`**。

:::

我们还可以创建动态对象**数组**。需要注意的是，释放时**必须在数组指针前加 `[]`**，这样编译器才知道**要释放哪些内存和调用多少次析构函数**。例如

```c++
A *p;
p = new A[100];
delete [] p; // 不能省略 '[]' ! // [!code error]
p = nullptr; // 避免野指针
```

串联一下，我们还可以利用上面的知识来实现一个动态数组：

```c++
char **chArray2;

// allocate the rows
chArray2 = new char* [ ROWS ];

// allocate the (pointer) elements for each row
for (int row = 0; row < ROWS; row++ )
    chArray2[ row ] = new char[ COLUMNS ];

// Reverse the creation algorithm to delete
for (int row = 0; row < ROWS; row++)
{
    delete [ ] chArray2[ row ];
    chArray2[ row ] = NULL;
}

delete [ ] chArray2;
chArray2 = nullptr;
```

::: tip 记得使用智能指针

`C++11` 引入了[智能指针](./结构化编程.md#智能指针-unique_ptr)，它可以自动管理内存，避免内存泄露和野指针的问题。前面介绍过了 `unique_ptr`，还有 `shared_ptr` 和 `weak_ptr`，它们都是智能指针的一种。

例如，我们可以采用以下几种方式创建一个指向字符串 `111` 的 `unique_ptr`：

```c++
auto ptr = std::make_unique<std::string>("111");
// 或者
std::unique_ptr<std::string> ptr(new std::string("111"));
```

:::

## `const` 成员

在任何可能的地方将成员设置为常量，可以进一步提高保护性。`const` 常量成员是**依附于对象**而非类的（与静态成员不同），因此它在每一个类中都有一个副本。`const` 常量的初始化需在构造函数的**成员初始化表**中进行。

而 `static const` 常量是在**编译期中的常量**，它**依附于类**而非对象。`static const` 常量的初始化只能在**定义**的时候立即进行。

如果一个对象被声明为 `const`，那么它的**所有成员变量**都不可以被修改。这一对象中的成员函数，有的是可以调用的，有的不行，其区别在于**是否修改了成员变量**。至于不修改成员变量的成员函数，我们可以在函数参数列表的括号后加 `const`，例如：

```c++
class A{
  	int x, y;
public:
  	A(int x1, int y1);
  	void f();
  	void show() const;
}
```

无论是否加 `const`，编译器还是会阻止对 `const` 对象成员变量的修改。其实 `void show() const;` 等价于

```c++
void show(const A* const this);
```

相当于一个指向常量的指针常量。

::: warning 可以绕过这一限制吗...？

`C++` 总归是一个自由的国度。可以利用引用来间接修改，看下面的例子：

```c++
class A{
    int a{0};
    int &indirect_a;
public:
    A():indirect_a(a){}
    void f() const{
        indirect_a++;
    }
};

int main(){
    const A a;
    a.f(); // 可以增加 a 的值 // [!code ++]
}

```

这是因为 `indirect_a` 是一个引用，我们没有修改它的值，而是修改了它指向的值，并且我们也没有直接修改成员变量 `a`，所以我们可以绕过 `const` 限制。
:::

## 静态成员

**静态成员变量**提供了**同一个类中不同对象间共享变量**的方法。如果我们直接把它定义为全局变量，那么就丧失了 $\text{OOP}$ 的数据保护，还会导致**名空间污染**。

我们可以在类中的成员变量的类型名前加 `static` 声明静态成员变量，在类外对其进行定义。例如：

```c++
// in .h
class A{
		static int shared;
		...
}
// in .cpp
int A::shared = 0; 
```

如果是**静态常量**，则必须在**声明时进行定义**。

静态成员函数与之类似，它**不需要初始化类即可调用**，相当于类中的全局函数。

> [!NOTE] 类也是对象
>
> 类也可以看作是对象。因此，也可以使用它的成员变量或函数，只不过语法上有一些区别：
>
> - 调用**类**中的成员，用**命名空间作用域运算符`::`**，如`A::foo`，`A::a()`。
> - 调用**对象**中的成员，用**点运算符`.`**，如`a.bar`，`a.b()`。

## 友元

当我们希望在某个类中访问另一个类的**私有成员变量**，并且**不希望破坏**被访问类的私有性（如，不将那个私有成员变量声明为 `public` 或增加一个 `public` 方法来修改它），我们就可以使用友元。此外，使用友元直接访问，还可以增加效率，提高灵活性。

我们可以通过在希望被访问的类中添加访问者，并在前面增加 `friend` 关键字来声明友元。例如

```c++
void func();
class B;
class C{
  	...
  	void f();
};
class A{
  	...
    friend void func();	//友元函数
  	friend class B;	//友元类
  	friend void C::f();	//友元类成员函数
}
```

::: tip 类的设计原则

友元可以体现出类的设计原则：**尽量使功能完满但最小化**。这也遵循了[**迪米特法则**](../软件工程/面向对象的模块化.md#降低访问耦合的方法)。

:::

> [!IMPORTANT] 如何解决循环依赖
> 
> 使用友元时，可能会出现下面的情况
> 
> ```c++
> class A{
>     friend void B::func(A);
> };
> 
> class B{
> public:
>     void func(A a){}
> };
> ```
> 
> 这时，我们可以重新排列它们的顺序，并利用**前向声明**来改写
> 
> ```c++
> class A;
> 
> class B{
> public:
>     void func(A& a){}
> };
> 
> class A{
>     friend void B::func(A&);
> };
> ```
> 
> 在 `B` 中，我们只能使用 `A` 的指针或者引用，这时因为此时还不知道 `A` 类的具体内容，无法确定其大小，所以无法按值传递。

## 继承

### 单继承

单继承可以让子类拥有父类的成员变量和函数。其语法为：

```c++
class Son: public Father{
  	...
};
```

继承中引入新关键字 `protected`：派生类可以访问，外部其他类不可访问。而派生类无法访问父类的 `private` 成员。

> [!IMPORTANT] C++ 对同名函数的处理
>
> `Overriding`：子类有与父类同名且**参数相同**的函数，在类继承中出现；
>
> `Overloading`：有同名但**参数不同**的函数，与继承无关。
>
> `C++` 确定调用同名函数的过程为：先在当前类的名空间找名称，如果找到了就不再寻找上层（父类）的名空间；但如果找到了但没有参数匹配的版本，则报错。
>
>  `C++` 使用**静态**绑定来确定同名函数的调用（默认），这意味着在编译期间就可确定被调用的函数。因此，利用对象指针来调用成员函数是通过**指针的类型**进行确定的，而非指针实际指向的对象。比如
>
> ```c++
> class Base{
>   	void foo();
>   	...
> };
> 
> class A: public Base{
>   	void foo();
> }
> 
> Base* p = new A;
> p -> foo(); //调用 Base 类的 foo
> ```
> `C++` 默认采取静态绑定的方式（除了下面的虚函数）。这是 `C++` 的一个重要特性，可以借此判断许多同名函数调用问题。
> 
> 除了判断同名函数调用的问题，判断 `public`等访问权限也是静态的。因此，静态绑定思想应当**牢记**。**编译器希望为你多做一些事情。**
> 

派生类进行构造时，默认执行基类的默认构造函数。如果要执行基类的**非默认**构造函数，则**必须**在派生类构造函数的**成员初始化表中使用**。此外，也可以在派生类声明 `using Base::Base` 来继承所有 `Base` 基类的构造函数，这样就可以直接在派生类中任意使用，而非必须在成员初始化表中使用。

### 虚函数

前文我们介绍了静态绑定的特性，我们发现，当我们使用指针或引用调用函数时，编译器会根据指针或引用的类型来确定调用的函数。这种行为尽管十分高效，但也不甚灵活。我们当然希望在运行时根据对象的**实际类型**来确定调用的函数，这样可以更好地实现**多态**。

> [!NOTE] 我们为什么要使用指针或引用？
> 
> 一个问题是，我们为何不直接使用相应类型的对象呢？一方面是**多态**上的考虑，我们希望可以将用派生类对象替换基类对象，而不会出现问题。但是由于**对象切片**的存在，直接使用对象会导致派生类对象的数据被舍弃。另一方面，直接使用对象也会造成不必要的数据拷贝。
> 

> [!WARNING] 数据切片
> 数据切片指将派生类对象赋值到基类对象时，会**舍弃**掉派生类相对基类特有的数据和方法。
> 
> 解决办法：使用**引用或指针**赋值。


因此相对地，我们可以定义**动态绑定**，即在运行时根据对象的实际类型来确定调用。实现动态绑定的函数就是**虚函数**。虚函数可以通过在函数声明前加 `virtual` 关键字来定义。

#### 虚函数的特点

- 如果基类（或派生类）的某一函数被定义为虚函数，则它的派生类对其重定义的函数**均为虚函数**。这一属性可以一直**传递**下去。

- **静态、内联、构造**函数**不能**是虚函数。事实上，构造函数也没有必要是虚函数，因为它不涉及对象的指针和引用。

- 析构函数可以（也应该）是虚函数。**如果派生类申请了资源，则一定要定义虚析构函数。**

- 虚函数在**完成构造后才会绑定**。即：

  ```c++
  class A{
  public:
    	A() {f(); }
    	virtual void f();
    	void g();
  }
  
  class B: public A{
  public:
    	void f(){ g();}
    	void g();
  }
  
  //Construct B
  B b; // A::A(), A::f, B::B() // [!code warning]
  
  A* ptr = new B();
  ptr->f(); // B::f(), B::g() // [!code warning]
  //NOT: B::f(), A::g() // [!code error]
  ```

  如果在构造函数结束之前调用，则还是会调用**基类的虚函数**（派生类仍未构造完成）。

- `override` 关键字可以**明确**告知编译器当前函数是覆盖基类中的一个虚函数。应当及时添加 `override` 增加可读性，并防止潜在的拼写错误。

#### 纯虚函数

纯虚函数即在虚函数原型后面加上 `=0`。纯虚函数一般不给出具体实现（但也可以给出）。

有纯虚函数的类叫做**抽象类**。它不能用于创建对象，而只能用于为派生类提供框架；派生类提供抽象基类 的**所有成员函数的实现**。

::: tip 好的类设计

- [$\text{LSP}$ 替换原则](../软件工程/面向对象的模块化.md#降低继承耦合的方法)；
- 不要重定义与**继承而来的非虚成员函数**同名的成员函数；
- 使用虚析构函数；

:::

### 私有继承

//TODO
- 需要使用基类中的 protected 成员，或者重载 virtual function
- 不希望一个基类被 client 使用
- 节省空间

