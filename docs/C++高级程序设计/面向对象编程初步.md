# OOP

## 引入 OOP

传统的面向过程编程，数据经常是无监管的，分散在代码中。它们可以随意被多个函数访问、使用、修改。这通常是不安全的。最初的 $\text{OOP}$ 就设想将数据封装起来，对数据的使用作出更严格限制。

我们可以看下面的栈的例子：

::: code-group

```c++[面向过程]
#include<iostream.h>
#define STACK_SIZE 100
struct Stack{
  	int top;
  	int buffer[STACK_SIZE];
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.top = -1;
  	st2.top = -1;
  	int x;
  	push(&st1, 12);
  	pop(&st1, x);
}
```



```c++[OOP]
#include<iostream.h>
#define STACK_SIZE 100
class Stack{
private:
  	int top;
  	int buffer[STACK_SIZE];
public:
  	Stack(){top = -1;}
  	bool push(int i);
  	bool pop(int &i);
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.push(12);
  	int x;
  	st2.pop(x);
}
```

:::

::: warning `C++` 中的 `class` 和 `struct`

在 `C++` 中，`class` 和 `struct` 基本相同。区别在于 `class` 内成员变量的默认访问权限是 `private`，而 `struct` 是 `public`。

:::

早期 `C++` 提供的面向对象机制，大体上属于逻辑的范畴，可以理解为一种代码检查的机制。它通过 `Cfront` 直接编译为 `C` 代码，因此**面向对象的引入不会增大运行时开销**。

我们知道，对象是数据和操作的集合，对象之间通过函数调用传递信息，而类提供对象的抽象。如果仅有这些特性，可以被称为**基于对象的语言**（*Object-Based*），这也是早期 `Ada` 等语言采取的范式。然而现代的**面向对象的语言**（*Object-Oriented*），通常还支持**继承**的机制。

## 类

我们刚刚提到，类是对象的抽象，而对象是数据和操作的集合。因此，类中有相对应的概念：**成员变量**和**成员函数**。如下面的示例：

```c++
//Tdate.h
class Tdate{
public:
  	void SetDate(int y, int m, int d); // 成员函数
  	int isLeapYear(); // 成员函数
private:
  	int year, month, day; // 成员变量
}

//Tdate.cpp
void TDate::SetDate(int y, int m, int d){
  	year = y;
  	month = m;
  	day = d;
}
int TDate::isLeapYear(){return (year%4 == 0 && year % 100 != 0) || (year % 100 == 0);}
```

同普通的函数一样，成员函数也需要**先定义后使用**。可以直接在类中声明时定义，也可以在类外定义。在类外定义时应当在函数名前加上类名和作用域解析符 `::`。

可以将类的定义和成员函数的实现分别放在头文件和 `cpp` 文件中，如上文所示。但如果成员函数的**实现较为简单**，则可以一并放入头文件，编译器会自动进行**内联**操作。

::: tip 头文件还是模块`C++ 20`？

头文件是从 `C` 流传下来的声明库的所在地，它结构清晰，将声明和实现分离。但它的设计存在一些缺陷，如**重复包含问题、引入顺序**和**大型项目效率低下**的问题。

而 `C++20` 引入了模块机制，这是一种更现代化的代码组织方式。与传统的头文件不同，模块直接支持在语言层面进行依赖管理，以提高编译速度并减少复杂性。例如：

::: code-group

```c++[定义]
// math_utils.ixx
export module math_utils; // 定义模块并导出
export int add(int a, int b) { // 直接实现和导出函数
    return a + b;
}
```

```c++[使用]
import math_utils; // 导入模块
#include <iostream>

int main() {
    std::cout << add(3, 4) << std::endl;
    return 0;
}
```

:::

使用 `export` 和 `import` 来进行模块的导入和导出。

:::

### 构造函数

构造函数可以用来初始化对象，如**分配内存和初始化值**等。构造函数有如下特点：

- **与类同名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 可以重载。
- 默认为 `public`，但可定义为 `private`，接管对象的创建（如**单例模式**）。

如果没有显式声明构造函数，那么编译器会自动补全**默认构造函数**。默认构造函数是无参数的。但一旦显示声明了构造函数，编译器就不再提供（当然，还可以通过在函数声明后加 `=default` 来显式声明默认构造函数）。

构造函数会在创建对象时，选择一个合适的使用。一般来说，范式有两种：

- `ClassName` `object-name` = `ClassName`(`Args`)
- `ClassName` `object-name`(`Args`)

可以参考下面的例子：

```c++
class A{
public:
  	A();
  	A(int i);
  	A(char *p);
}

A a1 = A(1); //or 'A a1(1);' or 'A a1 = 1;', 调用 A(int i)
A a2 = A(); //or 'A a2;', 调用 A()
A a3 = A("abcd"); //or 'A a3("abcd");' or 'A a3="abcd";', 调用 A(char *p);
A a[4]; // 调用四次 A()
A b[5] = {A(), A(1), A('abcd'), 2, "xjy"};
```

### 成员初始化表

成员初始化表是构造函数的补充，它可以对初始化提供更细致的操控，并**提高效率**。此外，对于**常量和引用成员**，**必须在定义时初始化**。

成员初始化表的语法为构造函数名后面添加 `: Member1(Value1), Member2(Value2), ...`。成员的声明顺序是类中的定义顺序，而**不是成员初始化表的顺序。**

当初始化时，如果需要初始化的常量比较少，应当使用成员初始化表以提高效率。否则，应当考虑在构造函数体内赋值。

### 析构函数

析构函数当**对象消亡时**自动调用，应当在这当中回收这一对象使用的资源，如释放内存，关闭文件和网络非内存资源等。它有如下特点：

- **名字为 `~` 加类名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 默认为 `public`，但可定义为 `private`。

### 拷贝构造函数