# OOP

## 引入 OOP

传统的面向过程编程，数据经常是无监管的，分散在代码中。它们可以随意被多个函数访问、使用、修改。这通常是不安全的。最初的 $\text{OOP}$ 就设想将数据封装起来，对数据的使用作出更严格限制。

我们可以看下面的栈的例子：

::: code-group

```c++[面向过程]
#include<iostream.h>
#define STACK_SIZE 100
struct Stack{
  	int top;
  	int buffer[STACK_SIZE];
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.top = -1;
  	st2.top = -1;
  	int x;
  	push(&st1, 12);
  	pop(&st1, x);
}
```



```c++[OOP]
#include<iostream.h>
#define STACK_SIZE 100
class Stack{
private:
  	int top;
  	int buffer[STACK_SIZE];
public:
  	Stack(){top = -1;}
  	bool push(int i);
  	bool pop(int &i);
}
//implements for push and pop
//...

int main(){
  	Stack st1, st2;
  	st1.push(12);
  	int x;
  	st2.pop(x);
}
```

:::

::: warning `C++` 中的 `class` 和 `struct`

在 `C++` 中，`class` 和 `struct` 基本相同。区别在于 `class` 内成员变量的默认访问权限是 `private`，而 `struct` 是 `public`。

:::

早期 `C++` 提供的面向对象机制，大体上属于逻辑的范畴，可以理解为一种代码检查的机制。它通过 `Cfront` 直接编译为 `C` 代码，因此**面向对象的引入不会增大运行时开销**。

我们知道，对象是数据和操作的集合，对象之间通过函数调用传递信息，而类提供对象的抽象。如果仅有这些特性，可以被称为**基于对象的语言**（*Object-Based*），这也是早期 `Ada` 等语言采取的范式。然而现代的**面向对象的语言**（*Object-Oriented*），通常还支持**继承**的机制。

## 类

我们刚刚提到，类是对象的抽象，而对象是数据和操作的集合。因此，类中有相对应的概念：**成员变量**和**成员函数**。如下面的示例：

```c++
//Tdate.h
class Tdate{
public:
  	void SetDate(int y, int m, int d); // 成员函数
  	int isLeapYear(); // 成员函数
private:
  	int year, month, day; // 成员变量
}

//Tdate.cpp
void TDate::SetDate(int y, int m, int d){
  	year = y;
  	month = m;
  	day = d;
}
int TDate::isLeapYear(){return (year%4 == 0 && year % 100 != 0) || (year % 100 == 0);}
```

同普通的函数一样，成员函数也需要**先定义后使用**。可以直接在类中声明时定义，也可以在类外定义。在类外定义时应当在函数名前加上类名和作用域解析符 `::`。

可以将类的定义和成员函数的实现分别放在头文件和 `cpp` 文件中，如上文所示。但如果成员函数的**实现较为简单**，则可以一并放入头文件，编译器会自动进行**内联**操作。

::: tip 头文件还是模块`C++ 20`？

头文件是从 `C` 流传下来的声明库的所在地，它结构清晰，将声明和实现分离。但它的设计存在一些缺陷，如**重复包含问题、引入顺序**和**大型项目效率低下**的问题。

而 `C++20` 引入了模块机制，这是一种更现代化的代码组织方式。与传统的头文件不同，模块直接支持在语言层面进行依赖管理，以提高编译速度并减少复杂性。例如：

::: code-group

```c++[定义]
// math_utils.ixx
export module math_utils; // 定义模块并导出
export int add(int a, int b) { // 直接实现和导出函数
    return a + b;
}
```

```c++[使用]
import math_utils; // 导入模块
#include <iostream>

int main() {
    std::cout << add(3, 4) << std::endl;
    return 0;
}
```

:::

使用 `export` 和 `import` 来进行模块的导入和导出。

:::

### 构造函数

构造函数可以用来初始化对象，如**分配内存和初始化值**等。构造函数有如下特点：

- **与类同名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 可以重载。
- 默认为 `public`，但可定义为 `private`，接管对象的创建（如**单例模式**）。

如果没有显式声明构造函数，那么编译器会自动补全**默认构造函数**。默认构造函数是无参数的。但一旦显示声明了构造函数，编译器就不再提供（当然，还可以通过在函数声明后加 `=default` 来显式声明默认构造函数）。

构造函数会在创建对象时，选择一个合适的使用。一般来说，范式有两种：

- `ClassName` `object-name` = `ClassName`(`Args`)
- `ClassName` `object-name`(`Args`)

可以参考下面的例子：

```c++
class A{
public:
  	A();
  	A(int i);
  	A(char *p);
}

A a1 = A(1); //or 'A a1(1);' or 'A a1 = 1;', 调用 A(int i)
A a2 = A(); //or 'A a2;', 调用 A()
A a3 = A("abcd"); //or 'A a3("abcd");' or 'A a3="abcd";', 调用 A(char *p);
A a[4]; // 调用四次 A()
A b[5] = {A(), A(1), A('abcd'), 2, "xjy"};
```

### 成员初始化表

成员初始化表是构造函数的补充，它可以对初始化提供更细致的操控，并**提高效率**。此外，对于**常量和引用成员**，**必须在定义时初始化**。

成员初始化表的语法为构造函数名后面添加 `: Member1(Value1), Member2(Value2), ...`。成员的声明顺序是类中的定义顺序，而**不是成员初始化表的顺序。**

当初始化时，如果需要初始化的常量比较少，应当使用成员初始化表以提高效率。否则，应当考虑在构造函数体内赋值。

### 析构函数

析构函数当**对象消亡时**自动调用，应当在这当中回收这一对象使用的资源，如释放内存，关闭文件和网络非内存资源等。它有如下特点：

- **名字为 `~` 加类名**，**无返回类型**。
- 自动调用，不可单独直接调用。
- 在一个对象中只调用一次。
- 默认为 `public`，但可定义为 `private`。

### 拷贝构造函数

创建对象时，用同一类的对象对其进行初始化，这就是**拷贝构造**。自定义拷贝构造函数的**语法**是：

```c++
public:
		A(const A& a){
      	// Your own implemention...
    }
```

调用拷贝构造函数的场景有：

- `A b = a` 初始化赋值时；
- 函数按值传参时；
- 函数返回一个类时；

可以看出，如果将对象想象成 `int` 类型，则拷贝构造发生在大多数初始化值传递的情形。

::: danger 如果自定义了拷贝构造函数...

如果类中含有**自定义**的拷贝构造函数，那么在执行拷贝之前，会先执行新对象的**默认构造函数**（注意，**即使有自定义的构造函数，也会执行默认的！**），然后再执行自定义的拷贝构造函数。否则，如果没有进行自定义，直接调用成员对象的**默认拷贝函数**。

也就是说，如果自定义了拷贝构造函数，编译器就不会自己发挥，而是按照最简单的方式执行（即初始化）。

:::

但是，有时拷贝构造函数也会拖慢速度，例如下面的代码：

```c++
string generate(){
  	return string("test");
}
string S = generate();
```

这段简短的代码竟然执行了两次拷贝构造函数（假设没有移动构造函数的话）！一次用于将 `generate()` 临时变量拷贝到调用者栈帧中的无名变量，另一次用于将无名变量拷贝至 `S`。事实上，我们只需要将临时变量中的地址传给 `S` 就行了（类似值传递和引用传递的区别）。下面我们介绍的移动构造函数，解决了这一问题。

### 移动构造函数

左值是能通过名称访问的一块内存，而右值要么没有名称，要么无法被访问。非 `const` 的引用是一个左值。右值对象一般是没有名称的，或者是一个临时对象。因此许多情况下，右值的内存是一经赋值，不会再次被使用的。这时，我们可以直接在赋值时让左值来**全盘接管**右值的内存，就省去了拷贝构造的时间，这就是**移动构造函数**的主要思想。

移动构造函数的语法是：

```c++
public:
	A(A&& rvalue){
      	// Your own implemention...
    }
```

一般而言，移动构造函数不应该申领任何资源，所以不该抛出异常，可以加上 `noexcept` 关键字。

例如，我们可以看下面矩阵类 `Matrix` 的例子：

```c++
class Matrix {
    int n{0};
    int *mat{nullptr};

public:
    // Some constructors and functions...

    Matrix(Matrix && other) noexcept :n(other.n), mat(other.mat){
        other.mat = nullptr;    // 将资源完全移交给新对象
    }

    Matrix& operator=(Matrix && other) noexcept{
        if(n!=other.n){
            return *this;
        }
        if(this != &other){
            delete [] this->mat;    // 注意：必须先释放原有资源   // [!code error]
            this->mat = other.mat;  // 移交资源
            other.mat = nullptr;    // 将资源完全移交给新对象
        }
        return *this;
    }

    // Destructor...
}
```

这样，当希望将**右值临时对象转交给左值**时，通过只转交地址，我们就可以避免上文的拷贝构造函数的问题。

> [!IMPORTANT] 注意
> 一般来说，**移动构造函数和拷贝构造函数是互斥的**，因为它们调用的时机有重叠，但是具体的操作是不同的。因此，我们可以通过 `=delete` 来禁用拷贝构造函数，只保留移动构造函数。
>
> 此外，移动构造函数一般还需要**重载赋值运算符**，以应对一般的赋值操作。

::: tip 重载运算符注意释放资源

在进行有重载运算符的移动构造时，要注意**提前释放被顶替**的资源，防止内存泄漏。

此外，还需要检查**自赋值**的情况，避免资源被提前释放。

:::

`lvalue` 是不能赋值给 `rvalue` 的。但我们可以使用 `std::move(lvalue)`，这将会生成一个对应的 `rvalue`。

## 动态对象

动态对象存放在**堆**上，而前面介绍的对象存放在**栈**上。`C++` 引入 `new` 和 `delete` 来新建和释放动态对象，实现内存管理。使用它们而非 `malloc` 和 `free` 的原因是：可以正确操作构造函数和析构函数。

`new` 的主要任务是：先在堆中申请内存，然后选择合适的构造函数进行调用；`delete` 的主要任务是：先调用析构函数，然后回收堆中的内存。

动态对象的创建和释放可以参考下面的例子：

```c++
A *p, *q;
p = new A; // 申请内存，调用 A 的默认构造函数或者 A::A() (如果有的话)
q = new A(1); // 申请内存，调用 A::A(int)

delete p; // 调用析构函数，释放内存
delete q; // 调用析构函数，释放内存
```

与栈上的对象不同，**动态对象的创建和释放是与作用域解耦的**，因此可以利用这一性质申请全局可用的内存空间，同时也要谨防**内存泄露和野指针**。

::: danger 内存泄露和野指针

**内存泄露**指一块内存没有任何指向它的指针，那么它的位置信息也就丢失了。此时，如果程序不关闭，这一块内存就再也无法分配给其他对象，也就无法被使用了。因此，解决办法是在最后一个指向他的指针消失前，把内存释放。

**野指针**指指针指向的那块内存不可用，这很可能是因为指针没有正确初始化，或先前指向的内存区域已经被释放。前者的解决办法是严格遵循 $\text{RAII}$ 原则，后者的解决办法是在每次 `delete` 时把相应的指针全部设为 `NULL`。

:::

我们还可以创建动态对象**数组**。需要注意的是，释放时**必须在数组指针前加 `[]`**，这样编译器才知道**要释放哪些内存和调用多少次析构函数**。例如

```c++
A *p;
p = new A[100];
delete [] p; // 不能省略 '[]' !
```

## `const` 成员

在任何可能的地方将成员设置为常量，可以进一步提高保护性。`const` 常量成员是**依附于对象**而非类的（与静态成员不同），因此它在每一个类中都有一个副本。`const` 常量的初始化可以在构造函数的**成员初始化表**中进行。

而 `static const` 常量是在**编译期中的常量**，它**依附于类**而非对象。`static const` 常量的初始化只能在定义的时候立即进行。

如果一个对象被声明为 `const`，那么它的**所有成员变量**都不可以被修改。这一对象中的成员函数，有的是可以调用的，有的不行，其区别在于**是否修改了成员变量**。至于不修改成员变量的成员函数，我们可以在函数参数列表的括号后加 `const`，例如：

```c++
class A{
  	int x, y;
public:
  	A(int x1, int y1);
  	void f();
  	void show() const;
}
```

无论是否加 `const`，编译器还是会阻止对 `const` 对象成员变量的修改。其实 `void show() const;` 等价于

```c++
void show(const A* const this);
```

相当于一个指向常量的指针常量。

::: warning 可以绕过这一限制吗...？

`C++` 总归是一个自由的国度。可以利用引用来间接修改，看下面的例子：

```c++
class A{
    int a{0};
    int &indirect_a;
public:
    A():indirect_a(a){}
    void f() const{
        indirect_a++;
    }
};

int main(){
    const A a;
    a.f(); // 可以增加 a 的值 // [!code ++]
}

```

这是因为 `indirect_a` 是一个引用，我们没有修改它的值，而是修改了它指向的值，并且我们也没有直接修改成员变量 `a`，所以我们可以绕过 `const` 限制。
:::