# 变异测试

## 变异测试背景

变异意味着**不同、变化和产生新知识**。
<br>
**正向变异**：修复错误的程序、产生新的测试用例；
<br>
**反向变异**：产生错误的程序片段、生成恶意测试用例。

测试人员一般比较关注这两个问题：如何产生好的测试用例？**这一测试用例应当尽可能地反映出系统的缺陷**。如何评估测试套件的质量？**这一评估方式应当提高测试的置信度**变异测试在生成测试用例和评估软件测试的过程中显示出了优越性。

变异测试的产生，主要通过**模拟缺陷**与**量化缺陷监测能力**两个部分。模拟时变异产生错误版本，模拟探测 $\mathrm{Bug}$ 的过程；量化时来评估变异得分。

## 变异测试过程

**变异体**：基于一定的**语法**（$\mathrm{Syntax}$）变换规则，通过对源程序进行程序变换）（$\mathrm{Program~Transformation}$）得到的一系列变体。

![Screen Shot 2024-09-09 at 4.33.45 PM](<Screen Shot 2024-09-09 at 4.33.45 PM.png>)

**变异得分**：变异测试对测试套件错误检测能力的量化。定义杀死为变异体导致某个测试用例运行失败，即测试用例检测到变异体，其数量为 $mut_k$；存活反之，其数量为 $mut_s$​。那么变异得分的公式为
$$
score = \frac{mut_k}{mut_k+mut_s}\times 100\%
$$
**缺陷传播的三种过程**

- $R\& E$：缺陷所在的位置可以被执行到（$\mathrm{Weak~Mutation}$）
- $I$：缺陷的执行影响了程序的状态（$\mathrm{Firm~Mutation}$）
- $P\&PR$：程序状态的影响传播到了输出（$\mathrm{Strong~Mutation}$）

**杀死条件**：可观测的程序输出（$P\&PR$）；程序的中间态（$I$​）；

::: tip 变异体的分类

- 等价变异体：变异体与待测程序**语法不同，语义相同**；
- 重复变异体：变异体之间**语法不同，语义相同**；
- 蕴含变异体：若能杀死变异体 $A$ 的测试用例都能杀死变异体 $B$，则 $A$ 蕴含 $B$。**这种蕴含是基于语义的，而不是基于测试用例的。**

:::

**变异算子**：**一系列语法变化规则**，是变异的依据，反映出测试人员关注的缺陷种类。它的基本形式有：对程序的源代码进行变换；对程序的编译结果或中间表示进行变换，如更改字节码；元变异。

::: tip 变异测试为什么是有效的？

变异测试的有效性基于三个假设：

- 缺陷是简单的，且是可模拟的：**一个老练程序员编写的错误程序与正确程序相差不大**。
- 缺陷是可以叠加的：**复杂变异体可以通过耦合简单变异体得到。**
- 缺陷的检测是有效的：测试用例具备缺陷检测能力。

:::

## 变异测试应用