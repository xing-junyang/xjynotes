# 回归测试

在软件产品的开发和维护的过程中，因为**移除软件内在的缺陷、添加新功能、重构现有代码**等操作，需要对代码进行修改，执行软件演化。此外，随着以统一过程和敏捷方法为代表的增量、迭代式开发过程的流行，**软件演化频率也随之迅速提高**。因此，**确保软件演化过程中的质量愈发重要。**

**回归测试**作为一种有效的方法，可有效保证代码修改的正确性并避免代码修改对被测程序其他模块产生副作用。回归测试一般占软件产品测试预算的80%以上，占软件维护预算的 50%以上。

由于回归测试的应用场景是软件演化，那么就一定有先前的测试用例套件可以用来复用。但是，如果我们直接执行先前的所有测试用例，又会有很多问题。首先就是已有**测试用例存在大量冗余**，此外还有测试用例失效和缺失等一系列问题。因此，**回归测试优化的主要研究方向**就是如何从原有用例中提炼出对本次演化有效的用例，并修复失效或缺失的用例。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src='/image/Screen Shot 2024-09-30 at 2.39.09 PM.png' alt="" style="width:80%;"></img>
    <p style="font-size: 12px; color: gray;">回归测试优化流程图</p>
</div>

## 回归测试优化

回归测试优化的范畴大概包含以下的五个方向：

- **测试用例修复**：识别出因相关模块的外部接口或内在语义发生变更为失效的用例，并其进行修复。
- **测试用例选择**：通过分析代码修改，从已有测试用例中选择出所有可检测代码修改的测试用例，并确保未被选择的测试用例在修改前后程序上的执行行为保持一致。
- **测试用例扩充**：在代码修改影响分析基础上，对已有测试用例集的充分性进行评估，若不充分则设计新的 测试用例以确保对代码修改的充分测试。
- **测试用例缩减**：在满足指定测试需求覆盖前提下，识别并移除冗余测试用例来降低回归测试用例集规模。
- **测试用例优先级**：当测试预算不足以执行完所有测试用例时，可以基于特定优先级准则，对测试用例进行优先级排序以优化其执行次 序，旨在最大化优先级目标，例如测试用例集的缺陷检测速率。

## 测试用例优先级

通过设定特定优先级准则（执行时间，代码覆盖等），**对测试用例进行优先级排序以优化其执行次序**，旨在提高测试用例集的故障检测率和效率。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src='/image/Screen Shot 2024-09-30 at 3.22.35 PM.png' alt="" style="width:80%;"></img>
    <p style="font-size: 12px; color: gray;">测试用例优先级的获取</p>
</div>

主要步骤如下：

- **特征提取**：选择合适的特征表示测试用例。
- **优先级策略**：操纵测试用例的特征进行优先级排序。
- **评估准则**：选择恰当指标评估优先级排序的效果。

::: tip 特征提取

特征提取的方法有很多。根据 $\mathrm{PIE}$ 模型理论我们知道，只有运行的缺陷才能被检测到，那么，我们可以**基于源码特征**，提取出语句、分支和函数特征，并计算测试用例对这些特征的覆盖率。我们还可以**基于文本特征**来提取，计算出测试数据文本（如字符串或者量化为向量）之间的差异性（海明距离，曼哈顿距离，编辑距离：即从一个字符串编辑成另一个需要多少步键盘操作等）来表示特征。此外，还可以**基于缺陷特征**来提取，即在变更代码上进行变异测试，使用变异体杀死能力来度量测试用例的缺陷检测能力。还有一种直接**基于模型特征**的提取方式，通过对比修改前后模型可别出模型差异，在修改后的模型上执行所有测试用例，并基于测试用例对模型差异的覆盖信息进行优先级排序。

:::

例如，对于以下求最大公约数的缺陷代码：

```c
int gcd(int a, int b){
  	if(!a)	return b;
    while (b) {
      if (a > b) a = a - b;
      else	b = a - b; // should be “b = b - a;”
    }  
  	return b;
}
```

在第五行存在缺陷。那么，如果某些测试用例有更大的代码覆盖率，那么就能够以更大的概率检测出这一缺陷。所以，在这一代码中，我们可以使用代码覆盖率来作为一个**优先级策略**。对于优先级策略，一般有**贪心、相似性分析、搜索和机器学习**几种方法。

- **贪心**：分为**全局**贪心策略和**增量**贪心策略。全局贪心策略每次优先选择覆盖最多代码单元的测试用例，而增量贪心策略每轮优先挑选覆盖最多，且未被已选择用例覆盖代码单元的测试用例。在这两种策略下，如果多个用例相同则随机选择。
<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src='/image/Screen Shot 2024-09-30 at 3.45.08 PM.png' alt="" style="width:80%;"></img>
    <p style="font-size: 12px; color: gray;">贪心算法实例</p>
</div>

## 测试用例选择

测试用例选择旨在**从已有测试用例集中选择出所有可检测代码修改的测试用例**。它适用于因测试预算不足以致不能执行完所有测试用例的测试场景。最简单的测试用例选择策略是如果一个测试用例没有执行到变更部分所在的模块，那就不选择这一测试用例。当然，这种方法可能会舍弃掉某些有价值的测试用例。

## 测试用例集约减

测试用例约减指在满足对指定测试需求的覆盖前提下，通过**识别并移除冗余测试用例**来降低回归测试成本，在版本迭代时提高测试的效率。这一步可以类比变异体筛选和约减的过程。



