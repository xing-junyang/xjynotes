# 设计模式

**设计模式**是对常见设计的总结和抽象，既是一种**解决问题的思路**，同时也是一种**提高沟通效率的工具**。设计模式展示了如何构建具有良好面向对象设计特性的系统，是经过验证的面向对象经验。一般来说，设计模式不会直接提供代码，而是针对设计问题给出**通用解决方案**，需要结合实际问题进行应用。大多数设计模式和原则旨在解决软件中的**变化问题**，即它们常常试图将系统中变化的部分**封装**起来，从而使得系统在面对变化时能够保持灵活性和可维护性。

按照作用不同，可以将设计模式分为三类：**创建型模式**、**结构型模式**和**行为型模式**。而按照结构来说，可以分为类模式和对象模式。

本文将介绍一些常见的设计模式。

## 创建型模式

### 工厂模式

> 名称：工厂模式
> 
> 英文名称：`Factory Pattern`
> 
> 类型：**创建型模式**

#### 简单工厂模式（$\text{Simple Factory Pattern}$）

考虑一个可以提供不同类型按钮的组件库，不同的按钮继承自同一个按钮基类，这些按钮都对基类的样式进行了相应的修改。如果我们不希望了解按钮派生类的具体信息，而只希望通过相应的参数来获取（创建）新的派生类。这时就可以采用**简单工厂模式**。

简单工厂模式又称为静态工厂模式，属于**创建型模式**。在简单工厂模式中，可以通过参数不同返回不同的实例。

简单工厂模式的结构如下：

- **工厂角色** `Factory`：负责创建所有实例的内部逻辑。工厂角色中应当包含一个静态方法，用于接收一个参数，并返回一个相应的创建好的对象。
- **抽象产品角色** `Product`：定义了所有具体产品的公共接口。
- **具体产品角色** `ConcreteProduct`：实现了抽象产品角色定义的接口的具体产品。

简单工厂模式**将对象的创建和对象的业务本身分离**，降低了系统的耦合度。当你需要一个类，只需要传入一个正确的参数，就可以获取想要的对象，而不需要知道任何创建的细节，甚至连具体产品的类名都可以不知道。

> [!NOTE] 简单工厂模式的简化
> 
> 有些情况下，**工厂角色与抽象产品角色可以是同一个**。也就是说，把静态工厂方法写到抽象产品类中。
>
> <div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
>    <img src="/image/Screen Shot 2025-03-26 at 8.55.22 PM.png" alt="" style="width: 60%" />
>    <p style="font-size: 12px; color: gray;">简单工厂模式的简化</p>
> </div>

一般来说，当工厂类**负责创建的对象比较少**，且客户端**不需要了解创建细节**，也**不需要**工厂角色**形成继承层次结构**时，通常使用易于实现的**简单工厂模式**。其他情况下使用简单工厂模式反而会降低系统设计的质量，可见下文。

#### 工厂方法模式（$\text{Factory Method Pattern}$）

简单工厂模式最大的问题是**工厂的职责相对过重**，增加新的产品需要修改工厂类的判断逻辑。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。这违反了**开闭原则**。下面，**工厂方法模式**将解决这一问题。

工厂方法模式，又叫**虚拟构造器**（$\text{Virtual Constructor}$）模式或者**多态工厂**（$\text{Polymorphic Factory}$）模式，同样是一种**创建型模式**。

工厂方法模式主要改进了工厂类的组织方式。在工厂方法模式中，我们**不再设计一个具体的工厂类**来统一负责所有产品的创建，而是将工厂类抽象为一个接口，将具体的产品创建过程**交给专门的具体工厂类来实现**。这样，每一个具体的产品都有一个对应的具体工厂类，而所有的具体工厂类都实现了工厂接口。在新增产品时，只需要新增一个具体产品类和一个具体工厂类即可，不需要修改原有的代码。这样，工厂方法模式就遵循了**开闭原则**。

客户端在使用工厂创建产品时，**只需关心所需产品对应的具体工厂类**是什么就可以了，无须关心创建细节，同样也无须知道具体产品类的类名。

```java
// 抽象工厂类
public abstract class PayMethodFactory {
    public abstract AbstractPay getPayMethod(); 
}

// 具体工厂类
public class CashPayFactory extends PayMethodFactory {
    public AbstractPay getPayMethod() {
        return new CashPay(); // CashPay 为产品类
    }
}

// 客户端代码
PayMethodFactory factory; 
AbstractPay payMethod; 
factory = new CashPayFactory(); 
payMethod = factory.getPayMethod(); 
payMethod.pay();
```

为了提高系统的可扩展性和灵活性，在**定义工厂和产品时都必须使用抽象层**，以应对具体工厂和产品可能发生的变更。在实际开发中，经常通过**配置文件和反射结合**的方式来自动创建对象。

::: tip 使用配置文件和反射来自动创建对象

在实际的应用开发中，一般将具体工厂类的实例化过程进行改进，不直接使用 `new` 关键字来创建对象，而是**将具体类的类名写入配置文件**中，再通过 Java 的**反射机制**，读取 `XML` 格式的配置文件，根据存储在 `XML` 文件中的类名字符串生成对象。

```xml
<?xml version="1.0"?> 
<config>
    <className>CashPayFactory</className> 
</config>
```

**Java 反射**是指在程序**运行时**获取**已知名称的类或已有对象的相关信息**的一种机制。可通过 `Class` 类的 `forName()` 方法返回与带有给定字符串名的类或接口相关联的 `Class` 对象，再通过 `newInstance()` 方法创建此对象所表示的类的一个新实例，即**通过一个类名字符串得到类的实例**。

```java
Class c = Class.forName("CashPayFactory");
PayMethodFactory factory = c.newInstance(); 
return factory;
```
:::


工厂方法模式的缺点在于添加新产品时需要添加新的工厂类，这样会导致类的数量增加；此外，还有可能使用 DOM、反射等技术。这些会增加系统的复杂度，并提高了编译运行的代价。

#### 抽象工厂模式（$\text{Abstract Factory Pattern}$）

无论是简单工厂模式还是工厂方法模式，它们都只能创建同一类产品（即继承自同一接口或抽象类的产品）。如果我们需要创建多个**不同类别**或**位于不同等级结构**的产品，那么我们就需要使用**抽象工厂模式**。

抽象工厂模式提供一个创建一系列**相关或相互依赖对象**的接口，而无需指定它们具体的类。抽象工厂模式又称为 `Kit` 模式，同样属于**对象创建型**模式。

::: tip 产品族和产品等级结构

- **产品族**：指由**同一个工厂**生产的，位于不同产品等级结构中的一组产品。
- **产品等级结构**：指产品的继承结构。代表着**不同类别的产品**。

:::

抽象工厂模式解决的问题是**多种类产品和产品类之间等级结构**的问题，是所有形式的工厂模式中**最为抽象和最具一般性**的一种形态。它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

抽象工厂模式的结构如下：

- **抽象工厂** `AbstractFactory`：最高层次的抽象，定义了工厂的公共接口。
- **具体工厂** `ConcreteFactory`：实现了抽象工厂定义的接口，负责创建**一个产品族**中的产品。如下图中的 `WindowsFactory`、`UnixFactory` 等。
- **抽象产品** `AbstractProduct`：定义了一种类别的产品。抽象产品可以有很多个。如下图中的 `Button`、`Text`。
- **具体产品** `ConcreteProduct`：实现了抽象产品定义的接口，是一个具体的产品。如下图中的 `WindowsButton`、`UnixButton` 等。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-03-27 at 11.35.46 AM.png" alt="" style="width: 80%" />
    <p style="font-size: 12px; color: gray;">抽象工厂模式的一个例子</p>
</div>

抽象工厂模式**同样隔离了具体类的生成**，使得客户并不需要知道什么被创建。此外，当一个产品族的多个对象被设计为一起工作时，能够保证客户端始终只使用**同一个产品族**中的对象，这对于一些需要根据不同的环境创建不同的对象的系统来说是非常有用的。另外，和工厂方法模式一样，抽象工厂模式也是**符合开闭原则**的，当需要增加一个新的产品族时，只需要增加一个新的具体工厂类即可。

抽象工厂模式的缺点在于，**难以扩展抽象工厂来支持新种类的产品**，这是因为支持新种类的产品就要对抽象工厂角色及其所有子类的修改，显然是不方便的。**抽象工厂增加新的工厂和产品族较为方便，但是增加新的产品等级结构就比较麻烦**。因此如果系统的变化主要体现在新增产品族上，抽象工厂模式是一个很好的选择，否则需要慎重考虑。这被称为**开闭原则的倾斜性**。

抽象工厂模式中，如果只有一个产品族，可以省略抽象工厂角色，退化为**简单工厂模式**；如果只有一个产品等级结构，退化为**工厂方法模式**。

### 建造者模式（$\text{Builder Pattern}$）

> 名称：建造者模式
> 
> 英文名称：`Builder Pattern`
> 
> 类型：**创建型模式**

无论是在现实世界还是在软件系统中，都存在一些具有多种组成成分的复杂对象。对于大多数用户来说，它们无需知道这些对象的内部构造细节和组合这些组件的过程，只需要知道如何创建并使用这些对象。

**建造者模式**将一个复杂对象的**构建与其表示分离**，使得同样的构建过程可以创建不同的表示。建造者模式是一种**创建型模式**。它可以一步一步构造一个复杂的对象，用户不需要知道具体的建造过程和细节，只需要知道应当使用哪一个建造者即可创建相应的产品。新增产品时，只需要新增一个具体建造者即可，不需要修改原有的代码，符合**开闭原则**。

建造者模式主要有**四个角色**，其结构如下：

- **产品** `Product`：表示被构造的复杂对象。`Product` 类通常包含**多个组成部分**，这些部分可以是**对象**，也可以是**原子数据类型**。
- **抽象建造者** `Builder`：抽象建造者类，规范产品的组建，一般是由一个接口或抽象类实现。接口中定义了**产品的各个组成部分的建造方法**，以及**返回构建完成的产品的方法**。
- **具体建造者** `ConcreteBuilder`：具体建造者类，实现抽象类定义的所有方法。
- **指挥者** `Director`：指挥者类，负责设定实际的建造者，安排已有模块的顺序以调用建造者完成对象的构建。前者一般可以利用 `setBuilder()` 方法或初始化时设置，后者一般使用 `construct()` 方法完成。

> [!NOTE] 使用指挥者类的原因
> 
> 指挥者类一方面**隔离了客户与生产过程**，另一方面负责**控制产品的生成过程**。这样，客户端只需要知道具体的建造者即可，无需自行创建产品或控制产品的生成过程。

例如，下面是一个在 **KFC** 套餐中使用建造者模式的例子：

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-03-27 at 2.31.35 PM.png" alt="" style="width: 80%" />
    <p style="font-size: 12px; color: gray;">建造者模式的一个例子</p>
</div>

客户端可以这样去使用上图中的建造者模式：

```java
// 创建指挥者
KFCWaiter waiter = new KFCWaiter();
MealBuilder builder = new SubMealBuilderA();

// 指挥者设定建造者
waiter.setMealBuilder(builder);

// 指挥者开始建造，并返回产品
Meal meal = waiter.construct();
```

注意，如果产品的组成或构造过程之间存在较大的差异，则不适合使用建造者模式。**建造者模式的出发点是通过相同的建造过程构建不同的产品**。在这一基础上，如果需要生成的产品对象**有复杂的内部结构**、或者需要生成的产品对象的属性**相互依赖**（有构造顺序要求），则建造者模式是一个很好的选择。

> [!NOTE] 建造者模式的简化
> 
> 如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者；在这一基础上，还可以继续省略指挥者角色，让 `Builder` 扮演指挥者与建造者双重角色。
> 
> 注意，简化是建立在对需求的洞察之上的。简化一定会带来可扩展性上的损失，但如果确定不会进行扩展，那么简化是一个不错的选择。

### 原型模式（$\text{Prototype Pattern}$）

> 名称：原型模式
> 
> 英文名称：`Prototype Pattern`
> 
> 类型：**创建型模式**

有时，如果我们需要频繁创建复杂对象，我们可以尝试**复制**一个已有的对象，然后再进行修改。这种方式有时比直接创建一个新对象更加高效。而原型模式就利用了这一思想。

原型模式是一种**创建型模式**，它允许一个对象（**原型实例**）创建另一个与其相同且可定制的对象，同时无需知晓创建的细节。它一般包含以下几个角色：

- **原型** `Prototype`：声明一个克隆自身的接口。
- **具体原型** `ConcretePrototype`：实现 `Clone` 方法，这一方法复制自身。
- **客户** `Client`：让一个原型克隆自身从而创建一个新的对象。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-03-27 at 4.39.31 PM.png" alt="" style="width: 80%" />
    <p style="font-size: 12px; color: gray;">原型模式的一个例子</p>
</div>

使用原型模式克隆对象时，根据其成员对象的克隆情况，分为**浅克隆**和**深克隆**两种。浅克隆时，只复制对象本身，对于对象内部的引用类型，只是复制了引用，而不克隆其指向的对象；深克隆则是对对象本身以及对象内部的引用类型指向的对象都进行了克隆。

在 `Java` 中，可以通过**实现 `Cloneable` 接口**（能够实现克隆的 Java 类必须实现这一接口）和**重写 `clone()` 方法**来实现原型模式。`Object` 类含有一个 `clone()` 方法，它属于浅拷贝。下面的模版代码展示了如何实现原型模式：

```java
// 原型接口
public interface Prototype extends Cloneable {
    public Object clone();
}

// 具体原型
public class ConcretePrototype implements Prototype {
    public Object clone() {
        try {
            return super.clone(); // 调用 Object 类的 clone() 方法，实现浅拷贝 // [!code warning]
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype();
        Prototype clone = (Prototype) prototype.clone();
    }
}
```


如果需要深克隆，需要在 `clone()` 中自行实现对引用类型的拷贝。

总而言之，原型模式**简化了对象的创建过程**，**提供了简化的创建结构**（创建时不需要过度关心对象的类型与层次），**提高了新实例的创建效率**。使用深拷贝，还可以保存对象的状态（相当于快照）。然而，原型模式的缺点表现为**需要为每一个类配备一个克隆方法**（在修改已有类时违反开闭原则），并且**实现深克隆较为复杂**。

原型模式较为适用的情况包括：

- 创建新对象成本较大，**通过复制原型对象得到新实例再修改可能比使用构造函数创建一个新实例更加方便**；
- 系统要保存对象的状态，而对象的状态变化很小；
- 需要避免使用分层次的工厂类来创建分层次的对象；

## 行为型模式

### 策略模式（$\text{Strategy Pattern}$）

> 名称：策略模式
>
> 英文名称：`Strategy Pattern`
>
> 类型：**行为型模式**

让我们考虑一个名为 `SimDuck` 的模拟鸭子游戏，这一游戏用于展示各种不同鸭子来愉悦心情。这个应用程序的主要需求即模拟各种类型的鸭子，例如野鸭、红头鸭、诱饵鸭等。这些鸭子都有一些共同的行为，例如游泳、飞行等，但是它们也有一些不同的行为，例如呱呱叫、吱吱叫等。有时，我们需要为某些鸭子添加新的行为（**即变化**），例如潜水。我们如何设计这个应用程序，**使得它既能够保持灵活性，又能够避免代码重复呢？**

**继承并重写**（`override`）是一种解决方案。所有鸭子都继承 `BaseDuck` 父类，那么在添加新的行为时就可以在父类中添加新的方法，然后在子类中重写这个方法。但是这种方法有一个缺点，即我们需要为未添加这一行为的鸭子重写这个方法，这样会导致代码重复。另一种解决方案是使用**接口**，即为每一种行为定义一个接口，然后在每一个鸭子类中实现这些接口。但是这种方法也有一个缺点，即如果我们需要为某些鸭子添加新的行为，那么我们需要修改所有添加这一行为的鸭子子类，这也不是一个完美的方法。

我们重新从设计的角度考虑，可以发现这些方式都**没有从变化的角度出发**。先前的设计都是直接在实现部分进行修改，而并没有为变化的部分进行封装。可以看出，易变的部分是鸭子的**行为**，而不是鸭子的类型。因此，我们可以将鸭子的各类行为抽象出来，然后将其封装到几个类中。这样，当我们需要为某些鸭子添加新的行为时，我们只需要修改这个行为抽象类即可。在不同的鸭子类中，我们只要按需**引入**这些行为抽象类，然后**调用**它们的方法即可。这一设计是**依赖倒置原则**、**开闭原则**和**合成复用原则**的体现。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-08 at 11.33.24 AM.png" alt="" style="width: 95%"></img>
    <p style="font-size: 12px; color: gray;">修改后的 SimDuck 类图</p>
</div>

如果将鸭子看作是一个**上下文**，而将鸭子的行为看作是一个**策略**，那么，这一设计模式就是经典的**策略模式**（$\text{Strategy Pattern}$）。策略模式是一种**行为型模式**，它定义了一系列**算法**（**策略**），将每一个算法封装起来，并使它们可以互相替换（甚至在运行时！）。策略模式让算法**独立于**使用它的**客户**（**上下文**）变化。在具体的代码设计时，策略模式相关的类一般含有 **`Strategy`** 或 **`Policy`** 的命名。

策略模式的结构如下：

- **策略接口** `Strategy`：定义了所有支持的算法的公共接口。通常是一个接口或抽象类。
- **具体策略** `ConcreteStrategy`：实现了策略接口的具体算法。

策略模式的特点有：

- 可维护性和可复用性强，易于扩展。
- 策略可以在运行时进行替换。
- 可以提供一系列具有**相同行为、不同实现**的策略。然而，客户需要对策略的具体内容有了解，知晓每一个策略的优缺点，从而选择合适的策略。

> [!NOTE] Shared Pattern Vocabulary
>
> **前文提到，设计模式是一种提高沟通效率的工具**。使用设计模式时，通常会使用一些特定的术语来描述模式的结构和行为，这些术语有助于更好地理解和交流设计模式的概念。当你与其他开发者或团队使用模式进行交流时，你不仅是在传递一个模式名称，更是在传达该模式所代表的**一整套特质、特征和约束条件**——模式让你能够以简驭繁。其他开发者能迅速准确地理解你脑海中的设计意图。

### 状态模式（$\text{State Pattern}$）

> 名称：状态模式
> 
> 英文名称：`State Pattern`
> 
> 类型：**行为型模式**

有时一些对象的行为取决于一个或多个动态变化的属性，这样的属性可以称为**状态**。当状态改变时，对象的行为也会随之改变。状态模式就是为了解决这一问题而设计的。

状态模式是一种**行为型模式**，它主要包含如下的三个角色：

- **环境类** `Context`：持有一个状态对象的引用，并定义了一个接口来与状态对象进行交互。
- **抽象状态类** `State`：定义了若干接口，用于一些状态相关的操作供环境类调用。
- **具体状态类** `ConcreteState`：实现了抽象状态类的接口，**包括不同状态下的具体行为，以及各种状态之间的转换逻辑**。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-08 at 3.56.38 PM.png" alt="" style="width: 60%" />
    <p style="font-size: 12px; color: gray;">状态模式的一个例子</p>
</div>

环境类针对抽象状态类进行编程，其通常持有一个具体状态类的实例，这使其拥有状态。此外，环境类通常还有一个改变状态对象的方法 `setState(State newState)`。这样，当状态发生变化时，只需要**修改环境类所持有的实例**而不需要修改环境类的代码，就可以使环境类表现出不同的行为。这一修改可以发生在环境类本身，也可以在具体状态类中进行。因此，具体状态类通常持有一个对环境类的引用，以便在状态转换时能够修改环境类的状态。这样，就实现了对**转换规则的封装**。

当拥有多个环境对象的话，可以让多个环境对象共享一个状态对象（将其设置为静态），这样可以减少内存开销。

**状态模式的优点包括**：**封装了转换规则**，避免了使用大量的条件语句（如 `if`、`switch` 等）来处理状态转换；可以在**运行时改变对象的行为**，就好像改变了类的代码一样；将所有与某个状态相关的行为都封装在一个类中，符合单一职责原则；便于增加新的状态等。**缺点在于**：状态模式会导致**类的数量增加**；结构复杂，如果使用不当（如每个状态的行为划分不正确）的话将会导致混乱；对“开闭原则”不利，**增加新的状态需要修改负责状态转换的代码**。

通常，当对象的行为依赖某些属性并且根据这些属性的不同而有不同的行为时，可以考虑使用状态模式。此外，如果代码中包含大量的条件语句来处理状态转换，那么也可以考虑使用状态模式来简化代码并减少客户端和类库的耦合。一些应用的场景：`工作流`、`游戏中的角色状态`、`酒店预订`等。

> [!NOTE] 两种状态模式
> 
> - 简单状态模式：指状态均相互独立，状态之间没有转换关系。如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。
> - 可切换状态的状态模式：通过调用环境类的 `setState(State newState)` 方法来切换状态。这一情况下可能会违背“开闭原则”，因为需要修改状态转换代码来增加新的状态。

### 命令模式（$\text{Command Pattern}$）

> 名称：命令模式
> 
> 英文名称：`Command Pattern`/`Action Pattern`/`Transaction Pattern`
> 
> 类型：**行为型模式**

在软件设计中，我们经常需要向某些对象发送请求，但并不需要知道请求的接收者是谁，也不需要知道请求的具体实现细节。命令模式就是为了解决这一问题而设计的，使请求的发送和接收解耦。

命令模式是一种**行为型模式**，它将一个请求**封装为一个对象**。一般包含以下五个角色：

- **抽象命令** `Command`：声明了一个执行操作的接口。
- **具体命令** `ConcreteCommand`：实现了抽象命令接口，定义了与接收者之间的绑定关系，并调用接收者的相应操作。
- **接收者** `Receiver`：知道如何实施与执行一个请求相关的操作。
- **调用者** `Invoker`：负责调用命令对象执行请求。它不需要知道命令的具体实现细节，只需要知道如何调用命令对象的执行方法。
- **客户端** `Client`：保存相应的接收者和调用者，并创建具体命令对象。之后，客户端将具体命令对象与接收者关联起来，并将命令对象传递给调用者。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-08 at 4.46.45 PM.png" alt="" style="width: 70%" />
    <p style="font-size: 12px; color: gray;">命令模式的一个例子</p>
</div>

命令模式引入了抽象命令的接口，使得命令的调用者可以针对抽象命令接口进行编程，只有实现了具体命令才能与接收者产生关联。此外，命令的调用者和接受者之间相对独立，调用者不需要知道命令的具体实现细节、命令的执行时间、命令的执行过程，只需要知道如何调用命令对象的执行方法即可。

抽象命令接口可能还包含一些其他方法，例如 `undo()` 方法，用于撤销命令的执行。这样，命令模式还可以支持命令的撤销和重做操作。

**使用命令模式的优点包括**：**解耦了请求的发送者和接收者**，使得请求的发送者不需要知道请求的接收者是谁，降低了系统的耦合度；可以将请求封装为对象，从而支持请求的排队、记录日志、撤销等操作；符合开闭原则，新的命令可以很容易地加入到系统中。**缺点在于**：使用命令模式可能会导致某些系统有过多的具体命令类。

当系统需要将**请求调用者和请求接收者解耦**，或需要支持**请求的撤销、重做、排队、组合与定时执行**等功能时，可以考虑使用命令模式。常见的应用场景包括：`图形用户界面`（同一功能按钮的不同操作）等。



### 观察者模式（$\text{Observer Pattern}$）

> 名称：观察者模式
> 
> 英文名称：`Observer Pattern`/`Publish-Subscribe Pattern`/`Model-View Pattern`/`Source-Listener Pattern`/`Dependents Pattern`
> 
> 类型：**行为型模式**


### 中介者模式（$\text{Mediator Pattern}$）

> 名称：中介者模式
> 
> 英文名称：`Mediator Pattern`
> 
> 类型：**行为型模式**


### 模版方法模式（$\text{Template Method Pattern}$）

> 名称：模版方法模式
> 
> 英文名称：`Template Method Pattern`
> 
> 类型：**行为型模式**

## 结构型模式

### 适配器模式（$\text{Adapter Pattern}$）

> 名称：适配器模式
> 
> 英文名称：`Adapter Pattern`/`Wrapper Pattern`
> 
> 类型：**结构型模式**


### 组合模式（$\text{Composite Pattern}$）

> 名称：组合模式
> 
> 英文名称：`Composite Pattern`/`Part-Whole Pattern`
> 
> 类型：**结构型模式**


### 桥接模式（$\text{Bridge Pattern}$）

> 名称：桥接模式
> 
> 英文名称：`Bridge Pattern`
> 
> 类型：**结构型模式**


### 装饰器模式（$\text{Decorator Pattern}$）

> 名称：装饰器模式
> 
> 英文名称：`Decorator Pattern`
> 
> 类型：**结构型模式**


### 外观模式（$\text{Facade Pattern}$）

> 名称：外观模式
> 
> 英文名称：`Facade Pattern`
> 
> 类型：**结构型模式**


### 享元模式（$\text{Flyweight Pattern}$）

> 名称：享元模式
> 
> 英文名称：`Flyweight Pattern`
> 
> 类型：**结构型模式**


### 代理模式（$\text{Proxy Pattern}$）

> 名称：代理模式
> 
> 英文名称：`Proxy Pattern`
> 
> 类型：**结构型模式**

