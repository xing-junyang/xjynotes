# 软件架构部分

## 软件架构概述

什么是软件架构 **`Software Architecture`** ？$\text{IEEE}$ 定义为：软件架构是**系统的基本组织，体现在其组件、组件之间及其与环境的关系，以及支配其设计和演进的原则之中**。软件架构将整个系统分解为**多个组件、模块或子系统**，并定义它们的**行为、职责、接口**以及它们之间的**交互方式**。

软件架构设计是软件设计的一部分，**是一种高层次的设计活动，同时也是一系列的设计决策**。设计者通过将需求、约束等方面迭代式地进行综合考虑与决策，最终形成详细的架构设计方案（文档）。架构设计提供了一个更为抽象的整体视角，隐去了实现细节和复杂性，并体现出一种设计理念。因此，软件架构设计可以在满足种种功能需求的同时顾全大局，**兼顾非功能需求的实现**。软件架构设计的目标是**创建一个高质量的软件系统**。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-12 at 11.57.31 AM.png" alt="" style="width: 80%" />
    <p style="font-size: 12px; color: gray;">架构设计过程</p>
</div>

软件架构还可以从**多个视角**进行分析和描述。$\text{P. Kruchten}$ 提出了著名的 $\text{4+1}$ 视图模型，将软件架构分为以下五个视图：

- **逻辑视图** **`Logical View`**：描述架构中具有重要意义的元素及其之间的关系。
- **过程视图** **`Process View`**：描述架构中各元素的并发性和通信机制。
- **物理视图** **`Physical View`**：描述主要过程和组件如何映射到应用程序硬件上。
- **开发视图** **`Development View`**：捕获软件组件的内部组织结构，例如配置管理工具中的组织方式。
- **架构用例** **`Architecture Use Case`**：捕获架构的需求；与多个特定视图相关联。

实际上，**架构本身就是一组设计决策的集合**，可以将这些决策分为以下几类：

- **职责分配** `Allocation of responsibilities` 
- **协调模型** `Coordination model` 
- **数据模型** `Data model` 
- **资源管理** `Management of resources` 
- **架构元素间的映射** `Mapping among architecture elements` 
- **绑定时机的决策** `Binding time decisions` 
- **技术选型** `Choice of technology` 

软件架构是为实现需求的**最早的一批设计决策**，它代表着那些**最难改变、最应仔细考虑**的设计决策。架构设计不仅决定能否以预期的方式**满足需求**（包括功能和肺功能需求），还会影响**开发的投入、成本与风险**，甚至可以**指导框架的维护和修改**。另外，好的设计是**可重用的**，架构设计可以为后续的系统开发提供一个良好的基础，尤其是为整个产品线的建立和演进提供支持。

## 需求与质量属性

需求分为**功能性需求**和**非功能性需求**（即**质量属性**）。此外，架构设计还需要考虑**约束**等其他关注点。

功能性需求是指系统需要完成的具体功能或任务，描述了系统的具体行为，强调如何为利益相关者提供价值。它们通常包括用户故事、用例或功能规格等形式。**功能性需求很大程度上与架构相独立**——即使是最简单的单体架构也能满足很多功能性需求。

非功能性需求（$\text{Non-functional requirements, NFRs}$）是**整个系统的理想特性**，是系统应当在其功能需求之上提供的附加特性。质量需求对功能性需求或整个产品起到了限定和补充的作用。我们很难先设计一个满足所有功能性需求的系统，然后再去考虑非功能性需求——**非功能性需求必须时刻伴随着整个架构设计过程**。架构设计师需要在满足功能性需求的同时，综合考虑各种质量属性和约束，以形成一个平衡的架构设计方案。

约束是指在架构设计过程中需要**严格**遵守的限制条件或规则，是预先指定的设计决策。约束可以是技术性的（如编程语言、框架、平台等），也可以是业务性的（如法律法规、商业模式等）。它们通常也会影响架构设计的选择和实现方式。

### 质量属性

质量属性是架构设计中十分重要的一环，在做任何设计决策时都需要考虑。质量属性通常有两大类：

- **`Observable/External`** **可观测的**质量属性 ：指系统满足其行为上需求的程度或能力。它们通常可以通过测试或监控来评估，例如性能、可用性、可靠性、安全性等。
- **`Not observable/Internal`** **不可观测的**质量属性：指系统被维护、集成与测试的难易程度。它们通常与系统的内部结构和设计有关，例如可维护性、可扩展性、可重用性等。

通常来说，在开发计划中，功能性需求会被优先考虑，但是这种情况下系统经常会因为无法满足质量属性而被重新设计。因此，**架构设计阶段就是最适合去解决质量属性问题的阶段**。当然，没有质量属性可以完全孤立地存在于设计、实现或部署中，它们是一以贯之的。

质量属性的清晰定义同样重要，它们可以帮助在架构层面上评估设计。通常使用**质量属性场景**（$\text{Quality Attribute Scenarios}$）来描述质量属性。质量属性场景是一个具有固定结构的简单描述，通常分为：**通用场景**和**具体场景**。前者是独立于具体的系统的，是具体场景的框架；而后者则是针对特定系统的，是通用场景的实例。质量属性场景通常包括以下几个部分：

- **刺激** **`Stimulus`**：触发系统行为的事件或条件。当它发生时，系统需要做出响应。
- **刺激源** **`Source (of Stimulus)`**：激发刺激的来源，通常是一个**实体**（如用户、系统本身等）。
- **响应** **`Response`**：刺激到来后，系统对刺激的反应或行为。
- **响应度量** **`Response Measure`**：衡量系统响应的标准或指标，通常是一个**量化的值**（如时间、资源消耗等）以便进行测试。
- **环境** **`Environment`**：当刺激发生时，系统所处的情境或上下文，例如：正常运行、过载、宕机等。
- **产物** **`Artifact`**：质量属性针对的具体产品或系统/子系统。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-12 at 4.22.48 PM.png" alt="" style="width: 60%" />
    <p style="font-size: 12px; color: gray;">质量属性场景框架</p>
</div>

若要达到某个质量属性的目标，通常需要在架构设计中做出相应的设计决策。一些重复出现的设计决策可以被称为**战术**（$\text{Tactics}$），它们是实现质量属性的具体方法或手段。一组战术可以形成一个**架构策略**（$\text{Architectural Strategy}$）。不同的战术可以组成层级结构。

下面介绍了常见质量属性的具体场景示例：

| 质量属性                         | 刺激源           | 刺激         | 工件     | 环境      | 响应                                 | 响应度量                    |
|------------------------------|---------------|------------|--------|---------|------------------------------------|-------------------------|
| **Availability**<br>可用性      | Heartbeat 监视器 | 服务器无响应     | 处理器    | 正常操作    | 通知操作者继续操作                          | 没有停机时间                  |
| **Interoperability**<br>互操作性 | 车辆信息系统        | 发送当前位置     | 路况监控系统 | 系统运行前已知 | 路况监控结合当前位置和 Google 地图上的其他信息，并且进行汇总 | 我们的信息在 99.9% 的时间是正确的    |
| **Modifiability**<br>可修改性    | 开发者           | 希望修改 UI 界面 | 代码     | 设计时     | 进行修改和单元测试                          | 在 3 个小时内完成              |
| **Performance**<br>性能        | 用户            | 发起事务       | 系统     | 正常操作    | 事务被处理                              | 平均延迟不超过 2 秒             |
| **Security**<br>安全性          | 来自偏远地区心怀不满的员工 | 尝试修改支付率    | 系统内数据  | 正常操作    | 系统存储修改追踪                           | 正确数据在 1 天内恢复储并且进行篡改身份识别 |
| **Testability**<br>可测试性      | 单元测试者         | 单元测试完成     | 单元测试代码 | 开发时     | 记录结果                               | 3 小时内达到 85% 的路径覆盖       |
| **Usability**<br>易用性         | 用户            | 下载新应用      | 系统     | 运行时     | 用户高效地使用应用                          | 在 2 分钟以内的实验             |

以下是常见质量属性的战术板：

| 质量属性                         | <div style="width: 600px;">战术</div>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Availability**<br>可用性      | **检测故障** `Detect Faults` <br>  • Ping/Echo: 定期发送心跳包检测组件是否响应 <br>  • 监控 (Monitor): 实时监控系统性能指标 <br>  • 心跳 (Heartbeat): 组件间定期发送存活信号 <br>**故障恢复** `Recover from Faults` <br>  • 主动冗余 (Active Redundancy): 多个组件同时运行处理相同任务 <br>    • 被动冗余 (Passive Redundancy): 备用组件在主组件失效时接管 <br>    • 备用 (Spare): 保持备用资源随时可用 <br>    • 异常处理 (Exception Handling): 优雅处理预期的异常情况 <br>  • 影子状态 (Shadow): 让修复的组件在后台同步状态 <br>    • 状态重同步: 确保组件状态一致性 <br>    • 扩容重启 (Escalating Restart): 逐步重启更大范围的组件 <br>**预防故障** `Prevent Faults` <br>  • 从服务中移除: 主动隔离有问题的组件 <br>  • 事务处理: 确保操作的原子性 <br>  • 流量管控: 防止系统过载 <br>  • 预测模型: 基于历史数据预测潜在故障 |
| **Interoperability**<br>互操作性 | **定位**<br>• 发现服务：通过搜索已知的目录服务来定位服务。可利用多层间接寻址。 <br>**管理接口**<br>• 编排： 使用控制机制来协调、管理和排序特定服务的调用。 <br>• 裁剪接口： 为接口添加或移除功能。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| **Modifiability**<br>可修改性    | • **拆分模块**：如果被修改的模块包含大量功能，修改成本可能会很高。 <br> • **增强语义内聚性**：如果模块中的职责A和B不服务于相同的目的，应该通过创建新模块或将职责移动到现有模块来将它们放置在不同的模块中。 <br> • 封装为模块引入显式接口，并降低对一个模块的更改传播到其他模块的概率。 <br> • 使用**中介者**打破依赖关系。 <br> • 当两个模块受到相同更改影响时，对他们重构。 <br> • **延迟绑定**：在生命周期的不同阶段绑定某些参数的值，而不是在它们最初定义时绑定。                                                                                                                                                                                                                                                                                                                                          |
| **Performance**<br>性能        | **需求侧优化** <br> • 管理采样率（降低采样频率） <br> • 限制事件响应：当离散事件到达系统的速度过快无法处理时，这些事件必须被排队等待处理 <br> • 如果并非所有事件都同等重要，则对事件进行优先级排序 <br> • 通过使用中介者来增加处理事件流的资源，从而减少开销 <br> **资源侧优化** <br> • 增加资源（更快的处理器、额外内存、更快的网络等） <br> • 如果请求可以并行处理，则引入并发性 <br> • 维护计算的多个副本：使用负载均衡器将新工作分配给可用的副本服务器之一 <br> • 维护数据的多个副本：利用缓存或数据复制                                                                                                                                                                                                                                                                                                             |
| **Security**<br>安全性          | • **身份验证** `Authentication`：确保用户或系统的身份。<br> • **授权** `Authorization`：控制用户或系统对资源的访问权限。<br> • **加密** `Encryption`：保护数据在传输和存储过程中的安全性。<br> • **审计日志** `Audit Logging`：记录系统操作以便于事后审计和追踪。                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **Testability**<br>可测试性      | • **系统状态的控制与观测**： 包括建立机制来维护、控制和获取系统状态信息，具备记录/回放功能以重现故障状态，并使用沙箱环境隔离系统进行安全实验。 <br> • **复杂性的限制与管理**： 通过减少结构复杂性来降低测试难度。例如减少组件间依赖关系和外部环境依赖、限制类继承的数量和深度、控制多态性和动态调用的使用等。通过限制非确定性来降低行为复杂性，使系统行为更可预测和可测试。                                                                                                                                                                                                                                                                                                                                                                                                            |
| **Usability**<br>易用性         | • **用户主导支持**：系统应该响应用户的操作需求，提供取消、撤销、暂停/恢复等基本控制功能，并能够将相关操作对象聚合处理，让用户在操作过程中保持主动权和灵活性。 <br> • **系统智能支持**：系统需要建立并维护任务模型、用户模型和系统模型，通过理解操作上下文、用户知识水平和系统预期行为，为用户提供个性化的智能辅助和反馈，提升整体交互体验。                                                                                                                                                                                                                                                                                                                                                                                                                           |


> [!NOTE] 质量属性中一些需要关注的地方
> 
> - 可以使用 $\text{MTBF}$ 和 $\text{MTTR}$ 来量化可用性。在计算可用性时通常不考虑计划内停机时间。
>   - $\text{MTBF}$（Mean Time Between Failures）表示平均故障间隔时间，是系统在两次故障之间的平均运行时间。
>   - $\text{MTTR}$（Mean Time To Repair）表示平均修复时间，是系统在发生故障后恢复正常运行所需的平均时间。
>   - **可用率**可以通过以下公式计算：
>     $$\text{Availability} = \frac{\text{MTBF}}{\text{MTBF} + \text{MTTR}}$$
> - 故障管理存在层次关系：**故障点** `fault`（根本原因）→ **错误** `error`（中间状态）→ **故障** `failure`（可观察的系统失效）→ **停机时间** `outage`
> - **互操作性**中的两大重要方面：**发现**和**响应处理**。发现指使用服务者必须能够发现服务的位置、身份和接口；响应处理指服务端可以将响应正确地发送给相关方（如请求者、其他服务、广播等）。
> - 并非总要在可修改性上做得面面俱到。这当中需要考虑**为修改做准备**和**做出修改**之间的 `trade-off`。
> - 经常通过响应时间 `response time` 和吞吐量 `throughput` 来衡量性能。响应时间通常有两个主要影响因素：**处理时间** `processing time`（系统处理请求所需的时间）和**排队/阻塞时间** `queuing/blocked time`（请求在队列中等待处理的时间）。吞吐量是指单位时间内系统能够处理的请求数量。
> - 安全性的三原则 `CIA`：
>   - **机密性** **`Confidentiality`**：确保信息只能被授权的用户访问。
>   - **完整性** **`Integrity`**：确保信息在存储和传输过程中不被未经授权的修改。
>   - **可用性** **`Availability`**：确保授权用户可以在需要时访问信息。

## 架构模式

架构模式是指能够**应用于反复出现的设计问题**的**一系列架构设计决策**。架构模式为**上下文、问题和解决方案**提供了一种通用的关系框架。架构模式是在实践中不断演化和总结的。与领域特定软件架构（$\text{Domain-Specific Software Architecture, DSSA}$）不同，架构模式是更加**通用的**，可以应用于多个领域。它们通常是对某些设计问题的解决方案的抽象和总结。而与设计模式相比，架构模式更关注于系统的整体结构和组件之间的关系，而非更偏向实现的编程语言部分。

- **上下文** `Context`：一种反复出现的常见情境或环境，通常引发了某个问题。
- **问题** `Problem`：在特定上下文中需要解决的设计问题或挑战。
- **解决方案** `Solution`：对该问题的经过适当抽象的成功架构解决方案。

下面总结一些常见的架构模式：

| 模式类型     | 模式名称                                                              | 描述                                          | 优点                            | 缺点                              | 应用                              |
|----------|-------------------------------------------------------------------|---------------------------------------------|-------------------------------|---------------------------------|---------------------------------|
| 模块化模式    | **Layered Pattern**              <br> 分层模式                        | 将系统组织成层次结构，每层只能与相邻层通信，高层使用低层的服务             | 关注点分离清晰；易于维护和修改；可重用性高；便于测试和调试 | 性能开销较大；层次过多时复杂度增加；有时会导致不必要的间接调用 | 经典的企业应用架构，如OSI网络模型、MVC中的分层结构    |
| 组件-连接器模式 | **Microkernel Pattern**           <br> 微内核模式                 | 核心系统提供最小功能，其他功能通过插件扩展实现                     | 高度可扩展；功能模块化；便于第三方集成；系统稳定性好    | 核心设计复杂；插件间通信复杂；性能可能受插件影响        | 常见于操作系统、IDE、浏览器等需要扩展功能的系统       |
| 组件-连接器模式 | **Broker Pattern**            <br> 中继器模式                     | 通过中介组件协调分布式组件间的通信，解耦客户端和服务端                 | 位置透明性；服务动态发现；负载均衡；故障恢复能力强     | 单点故障风险；性能瓶颈；复杂性增加               | 分布式系统中广泛使用，如CORBA、Web服务、消息队列    |
| 组件-连接器模式 | **MVC Pattern**            <br> MVC模式                        | 将应用分为模型(Model)、视图(View)、控制器(Controller)三个组件 | 关注点分离；支持多视图；便于并行开发；易于维护       | 复杂度增加；小型应用可能过度设计；组件间依赖关系复杂      | Web开发的经典模式，衍生出MVP、MVVM等变体       |
| 组件-连接器模式 | **Pipe-and-Filter Pattern**        <br> 管道-过滤器模式            | 数据流经一系列过滤器组件，每个过滤器执行特定的数据转换                 | 可重用性高；并发处理能力强；易于理解和维护；支持增量开发  | 不适合交互式应用；共享状态困难；错误处理复杂          | Unix命令行工具、编译器、数据处理管道中常用         |
| 组件-连接器模式 | **Client-Server Pattern**      <br> 客户端-服务器模式            | 客户端请求服务，服务器提供服务和资源，明确分工                     | 集中管理；资源共享；安全性好；可扩展性强          | 服务器单点故障；网络依赖；可能成为性能瓶颈           | 最常见的分布式架构模式，Web应用、数据库系统的基础      |
| 组件-连接器模式 | **Peer-to-Peer Pattern**            <br> P2P模式            | 每个节点既是客户端又是服务器，节点间直接通信                      | 无单点故障；高可用性；资源利用率高；成本低         | 安全性难以保证；数据一致性复杂；网络拓扑动态变化        | 文件共享系统(BitTorrent)、区块链、分布式计算中应用 |
| 组件-连接器模式 | **Service-Oriented Architecture Pattern**            <br> SOA模式 | 通过标准接口提供松耦合的服务，服务可被不同应用重用                   | 服务重用性高；平台无关；松耦合；业务灵活性强        | 性能开销；复杂的服务治理；标准化要求高             | 企业级应用集成的主流架构，微服务架构的前身           |
| 组件-连接器模式 | **Publisher-Subscriber Pattern**       <br> 发布者-订阅者模式       | 发布者产生事件，订阅者接收感兴趣的事件，通过事件总线解耦                | 松耦合；动态订阅；可扩展性强；支持一对多通信        | 复杂的事件管理；难以保证消息传递；调试困难           | 消息队列系统、事件驱动架构、GUI框架中广泛应用        |
| 组件-连接器模式 | **Shared-Data Pattern**         <br> 共享数据模式               | 多个组件通过共享数据存储进行通信和协作                         | 数据一致性；持久化存储；简单直观；便于数据分析       | 性能瓶颈；并发控制复杂；组件耦合度高              | 数据库驱动的应用、数据仓库、知识管理系统            |
| 分配模式     | **Map-Reduce Pattern**    <br> Map-Reduce模式                  | 将大数据集分解为小块并行处理(Map)，然后合并结果(Reduce)          | 高度并行化；可处理大数据；容错性强；自动负载均衡      | 不适合实时处理；编程模型受限；中间数据存储开销大        | 大数据处理的核心模式，Hadoop、Spark等框架的基础   |
| 分配模式     | **Multitier Pattern**            <br> 多层模式                 | 将应用逻辑分布在多个物理层上，如表示层、业务层、数据层                 | 可扩展性强；关注点分离；便于维护；支持负载分布       | 网络延迟；复杂的部署；层间通信开销               | 企业级Web应用的标准架构，如三层架构、N层架构        |

其中，模式类型的含义大致如下：

- **模块化模式** `Modular Pattern`：将系统分解为多个模块或层次结构，每个模块或层次负责特定的功能或职责。**特指开发时需要关注的部分。**
- **组件-连接器模式** `Component-Connector Pattern`：将系统分解为多个组件和连接器，组件负责处理数据和逻辑，连接器负责组件间的通信。**特指运行时的动态表现。**
- **分配模式** `Allocation Pattern`：将系统的组件和连接器映射到物理资源上，描述它们如何在硬件或网络上分布。

## 架构设计方法
**TODO soon**
## 文档化架构
**TODO soon**