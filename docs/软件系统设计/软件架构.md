# 软件架构部分

**TODO soon**

## 软件架构概述

什么是软件架构 **`Software Architecture`** ？$\text{IEEE}$ 定义为：软件架构是**系统的基本组织，体现在其组件、组件之间及其与环境的关系，以及支配其设计和演进的原则之中**。软件架构将整个系统分解为**多个组件、模块或子系统**，并定义它们的**行为、职责、接口**以及它们之间的**交互方式**。

软件架构设计是软件设计的一部分，是一种高层次的设计活动，同时也是一系列的设计决策。设计者通过将需求、约束等方面迭代式地进行综合考虑与决策，最终形成详细的架构设计方案（文档）。架构设计提供了一个更为抽象的整体视角，隐去了实现细节和复杂性，并体现出一种设计理念。因此，软件架构设计可以在满足种种功能需求的同时顾全大局，**兼顾非功能需求的实现**。软件架构设计的目标是**创建一个高质量的软件系统**。

<div style="display: flex; align-items: center; justify-content: center; flex-direction: column; padding-top:10px">
    <img src="/image/Screen Shot 2025-06-12 at 11.57.31 AM.png" alt="" style="width: 80%" />
    <p style="font-size: 12px; color: gray;">架构设计过程</p>
</div>

软件架构还可以从**多个视角**进行分析和描述。$\text{P. Kruchten}$ 提出了著名的 $\text{4+1}$ 视图模型，将软件架构分为以下五个视图：

- **逻辑视图** **`Logical View`**：描述架构中具有重要意义的元素及其之间的关系。
- **过程视图** **`Process View`**：描述架构中各元素的并发性和通信机制。
- **物理视图** **`Physical View`**：描述主要过程和组件如何映射到应用程序硬件上。
- **开发视图** **`Development View`**：捕获软件组件的内部组织结构，例如配置管理工具中的组织方式。
- **架构用例** **`Architecture Use Case`**：捕获架构的需求；与多个特定视图相关联。

软件架构是为实现需求的**最早的一批设计决策**，它代表着那些**最难改变、最应仔细考虑**的设计决策。架构设计不仅决定能否以预期的方式**满足需求**（包括功能和肺功能需求），还会影响**开发的投入、成本与风险**，甚至可以**指导框架的维护和修改**。另外，好的设计是**可重用的**，架构设计可以为后续的系统开发提供一个良好的基础，尤其是为整个产品线的建立和演进提供支持。
## 需求与质量属性

## 架构模式

| 模式类型     | 模式名称                                                                | 描述                                          | 优点                            | 缺点                              | 应用                              |
|----------|---------------------------------------------------------------------|---------------------------------------------|-------------------------------|---------------------------------|---------------------------------|
| 模块化模式    | **分层模式**              <br>  (Layered Pattern)                       | 将系统组织成层次结构，每层只能与相邻层通信，高层使用低层的服务             | 关注点分离清晰；易于维护和修改；可重用性高；便于测试和调试 | 性能开销较大；层次过多时复杂度增加；有时会导致不必要的间接调用 | 经典的企业应用架构，如OSI网络模型、MVC中的分层结构    |
| 组件连接器模式  | **微内核模式**           <br>    (Microkernel Pattern)                   | 核心系统提供最小功能，其他功能通过插件扩展实现                     | 高度可扩展；功能模块化；便于第三方集成；系统稳定性好    | 核心设计复杂；插件间通信复杂；性能可能受插件影响        | 常见于操作系统、IDE、浏览器等需要扩展功能的系统       |
| 组件 连接器模式 | **中继器模式**            <br>   (Broker Pattern)                        | 通过中介组件协调分布式组件间的通信，解耦客户端和服务端                 | 位置透明性；服务动态发现；负载均衡；故障恢复能力强     | 单点故障风险；性能瓶颈；复杂性增加               | 分布式系统中广泛使用，如CORBA、Web服务、消息队列    |
| 组件 连接器模式 | **MVC模式**            <br>   (MVC Pattern)                           | 将应用分为模型(Model)、视图(View)、控制器(Controller)三个组件 | 关注点分离；支持多视图；便于并行开发；易于维护       | 复杂度增加；小型应用可能过度设计；组件间依赖关系复杂      | Web开发的经典模式，衍生出MVP、MVVM等变体       |
| 组件 连接器模式 | **管道-过滤器模**式        <br>    (Pipe-and-Filter Pattern)               | 数据流经一系列过滤器组件，每个过滤器执行特定的数据转换                 | 可重用性高；并发处理能力强；易于理解和维护；支持增量开发  | 不适合交互式应用；共享状态困难；错误处理复杂          | Unix命令行工具、编译器、数据处理管道中常用         |
| 组件 连接器模式 | **客户端-服务器模式**      <br>     (Client-Server Pattern)                 | 客户端请求服务，服务器提供服务和资源，明确分工                     | 集中管理；资源共享；安全性好；可扩展性强          | 服务器单点故障；网络依赖；可能成为性能瓶颈           | 最常见的分布式架构模式，Web应用、数据库系统的基础      |
| 组件 连接器模式 | **P2P模式**            <br>   (Peer-to-Peer Pattern)                  | 每个节点既是客户端又是服务器，节点间直接通信                      | 无单点故障；高可用性；资源利用率高；成本低         | 安全性难以保证；数据一致性复杂；网络拓扑动态变化        | 文件共享系统(BitTorrent)、区块链、分布式计算中应用 |
| 组件 连接器模式 | **SOA模式**            <br>   (Service-Oriented Architecture Pattern) | 通过标准接口提供松耦合的服务，服务可被不同应用重用                   | 服务重用性高；平台无关；松耦合；业务灵活性强        | 性能开销；复杂的服务治理；标准化要求高             | 企业级应用集成的主流架构，微服务架构的前身           |
| 组件 连接器模式 | **发布者-订阅者模式**       <br>    (Publisher-Subscriber Pattern)          | 发布者产生事件，订阅者接收感兴趣的事件，通过事件总线解耦                | 松耦合；动态订阅；可扩展性强；支持一对多通信        | 复杂的事件管理；难以保证消息传递；调试困难           | 消息队列系统、事件驱动架构、GUI框架中广泛应用        |
| 组件 连接器模式 | **共享数据模式**         <br>     (Shared-Data Pattern)                   | 多个组件通过共享数据存储进行通信和协作                         | 数据一致性；持久化存储；简单直观；便于数据分析       | 性能瓶颈；并发控制复杂；组件耦合度高              | 数据库驱动的应用、数据仓库、知识管理系统            |
| 分配模式     | **Map-Reduce模式**    <br>   (Map-Reduce Pattern)                     | 将大数据集分解为小块并行处理(Map)，然后合并结果(Reduce)          | 高度并行化；可处理大数据；容错性强；自动负载均衡      | 不适合实时处理；编程模型受限；中间数据存储开销大        | 大数据处理的核心模式，Hadoop、Spark等框架的基础   |
| 分配模式     | **多层模式**            <br>    (Multitier Pattern)                     | 将应用逻辑分布在多个物理层上，如表示层、业务层、数据层                 | 可扩展性强；关注点分离；便于维护；支持负载分布       | 网络延迟；复杂的部署；层间通信开销               | 企业级Web应用的标准架构，如三层架构、N层架构        |

## 架构设计方法

## 文档化架构

## 架构评估